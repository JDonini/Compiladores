Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decSeq
Rule 2     dec -> varDec
Rule 3     dec -> ID LPAREN paramList RPAREN LKEY block RKEY
Rule 4     dec -> type ID LPAREN paramList RPAREN LKEY block RKEY
Rule 5     varDec -> type varSpecSeq SEMICOLON
Rule 6     varSpec -> ID
Rule 7     varSpec -> ID ASSIGN literal
Rule 8     varSpec -> ID LCOR NUMBER RCOR
Rule 9     varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY
Rule 10    type -> INT
Rule 11    type -> STRING
Rule 12    type -> BOOLEAN
Rule 13    param -> type ID
Rule 14    param -> type ID RCOR LCOR
Rule 15    block -> varDecList stmtList
Rule 16    stmt -> ifStmt
Rule 17    stmt -> whileStmt
Rule 18    stmt -> forStmt
Rule 19    stmt -> breakStmt
Rule 20    stmt -> returnStmt
Rule 21    stmt -> readStmt
Rule 22    stmt -> writeStmt
Rule 23    stmt -> assign SEMICOLON
Rule 24    stmt -> subCall SEMICOLON
Rule 25    stmt -> error
Rule 26    ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY
Rule 27    ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
Rule 28    whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY
Rule 29    forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
Rule 30    breakStmt -> BREAK SEMICOLON
Rule 31    readStmt -> READ var SEMICOLON
Rule 32    writeStmt -> WRITE expList SEMICOLON
Rule 33    returnStmt -> RETURN SEMICOLON
Rule 34    returnStmt -> RETURN exp SEMICOLON
Rule 35    subCall -> ID LPAREN expList RPAREN
Rule 36    assign -> var ASSIGN exp
Rule 37    assign -> var PLUSASSIGN exp
Rule 38    assign -> var MINUSASSIGN exp
Rule 39    assign -> var MULTASSIGN exp
Rule 40    assign -> var DIVIDEASSIGN exp
Rule 41    assign -> var MODASSIGN exp
Rule 42    exp -> exp PLUS exp
Rule 43    exp -> exp MINUS exp
Rule 44    exp -> exp MULT exp
Rule 45    exp -> exp DIVIDE exp
Rule 46    exp -> exp MOD exp
Rule 47    exp -> exp EQUALS exp
Rule 48    exp -> exp DIFFERENT exp
Rule 49    exp -> exp GT exp
Rule 50    exp -> exp GTE exp
Rule 51    exp -> exp LT exp
Rule 52    exp -> exp LTE exp
Rule 53    exp -> exp AND exp
Rule 54    exp -> exp OR exp
Rule 55    exp -> NOT exp
Rule 56    exp -> UMINUS exp
Rule 57    exp -> exp QMARK exp COLON exp
Rule 58    exp -> subCall
Rule 59    exp -> var
Rule 60    exp -> literal
Rule 61    exp -> LPAREN exp RPAREN
Rule 62    var -> ID
Rule 63    var -> ID LCOR exp RCOR
Rule 64    literal -> NUMBER
Rule 65    literal -> STRING_LITERAL
Rule 66    literal -> FALSE
Rule 67    literal -> TRUE
Rule 68    paramList -> paramSeq
Rule 69    paramList -> empty
Rule 70    paramSeq -> param
Rule 71    paramSeq -> param COMMA paramSeq
Rule 72    varDecList -> varDec varDecList
Rule 73    varDecList -> empty
Rule 74    varSpecSeq -> varSpec
Rule 75    varSpecSeq -> varSpec COMMA varSpecSeq
Rule 76    decSeq -> dec
Rule 77    decSeq -> dec decSeq
Rule 78    stmtList -> stmt stmtList
Rule 79    stmtList -> empty
Rule 80    literalSeq -> literal
Rule 81    literalSeq -> literal COMMA literalSeq
Rule 82    expList -> expSeq
Rule 83    expList -> empty
Rule 84    expSeq -> exp
Rule 85    expSeq -> exp COMMA expSeq
Rule 86    empty -> <empty>

Terminals, with rules where they appear

AND                  : 53
ASSIGN               : 7 9 36
BOOLEAN              : 12
BREAK                : 30
COLON                : 57
COMMA                : 71 75 81 85
DIFFERENT            : 48
DIVIDE               : 45
DIVIDEASSIGN         : 40
ELSE                 : 27
EQUALS               : 47
FALSE                : 66
FOR                  : 29
GT                   : 49
GTE                  : 50
ID                   : 3 4 6 7 8 9 13 14 35 62 63
IF                   : 26 27
INT                  : 10
LCOR                 : 8 9 14 63
LKEY                 : 3 4 9 26 27 27 28 29
LPAREN               : 3 4 26 27 28 29 35 61
LT                   : 51
LTE                  : 52
MINUS                : 43
MINUSASSIGN          : 38
MOD                  : 46
MODASSIGN            : 41
MULT                 : 44
MULTASSIGN           : 39
NOT                  : 55
NUMBER               : 8 9 64
OR                   : 54
PLUS                 : 42
PLUSASSIGN           : 37
QMARK                : 57
RCOR                 : 8 9 14 63
READ                 : 31
RETURN               : 33 34
RKEY                 : 3 4 9 26 27 27 28 29
RPAREN               : 3 4 26 27 28 29 35 61
SEMICOLON            : 5 23 24 29 29 30 31 32 33 34
STRING               : 11
STRING_LITERAL       : 65
TRUE                 : 67
UMINUS               : 56
WHILE                : 28
WRITE                : 32
error                : 25

Nonterminals, with rules where they appear

assign               : 23 29 29
block                : 3 4 26 27 27 28 29
breakStmt            : 19
dec                  : 76 77
decSeq               : 1 77
empty                : 69 73 79 83
exp                  : 26 27 28 29 34 36 37 38 39 40 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 56 57 57 57 61 63 84 85
expList              : 32 35
expSeq               : 82 85
forStmt              : 18
ifStmt               : 16
literal              : 7 60 80 81
literalSeq           : 9 81
param                : 70 71
paramList            : 3 4
paramSeq             : 68 71
program              : 0
readStmt             : 21
returnStmt           : 20
stmt                 : 78
stmtList             : 15 78
subCall              : 24 58
type                 : 4 5 13 14
var                  : 31 36 37 38 39 40 41 59
varDec               : 2 72
varDecList           : 15 72
varSpec              : 74 75
varSpecSeq           : 5 75
whileStmt            : 17
writeStmt            : 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decSeq
    (76) decSeq -> . dec
    (77) decSeq -> . dec decSeq
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

<<<<<<< HEAD
    ID              shift and go to state 5
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    program                        shift and go to state 1
    decSeq                         shift and go to state 2
    dec                            shift and go to state 3
    varDec                         shift and go to state 4
    type                           shift and go to state 6

state 1

    (0) S' -> program .

=======
    ID              shift and go to state 7
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    type                           shift and go to state 4
    varDec                         shift and go to state 2
    decSeq                         shift and go to state 3
    program                        shift and go to state 8
    dec                            shift and go to state 5

state 1

    (10) type -> INT .

    ID              reduce using rule 10 (type -> INT .)
>>>>>>> master


state 2

<<<<<<< HEAD
    (1) program -> decSeq .

    $end            reduce using rule 1 (program -> decSeq .)


state 3

    (76) decSeq -> dec .
    (77) decSeq -> dec . decSeq
    (76) decSeq -> . dec
    (77) decSeq -> . dec decSeq
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    $end            reduce using rule 76 (decSeq -> dec .)
    ID              shift and go to state 5
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    dec                            shift and go to state 3
    decSeq                         shift and go to state 10
    varDec                         shift and go to state 4
    type                           shift and go to state 6

state 4

=======
>>>>>>> master
    (2) dec -> varDec .

    ID              reduce using rule 2 (dec -> varDec .)
    INT             reduce using rule 2 (dec -> varDec .)
    STRING          reduce using rule 2 (dec -> varDec .)
    BOOLEAN         reduce using rule 2 (dec -> varDec .)
    $end            reduce using rule 2 (dec -> varDec .)


<<<<<<< HEAD
state 5

    (3) dec -> ID . LPAREN paramList RPAREN LKEY block RKEY

    LPAREN          shift and go to state 11


state 6
=======
state 3

    (1) program -> decSeq .

    $end            reduce using rule 1 (program -> decSeq .)


state 4
>>>>>>> master

    (4) dec -> type . ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> type . varSpecSeq SEMICOLON
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 12

<<<<<<< HEAD
    varSpecSeq                     shift and go to state 13
    varSpec                        shift and go to state 14

state 7

    (10) type -> INT .

    ID              reduce using rule 10 (type -> INT .)
=======
    varSpec                        shift and go to state 10
    varSpecSeq                     shift and go to state 11

state 5

    (76) decSeq -> dec .
    (77) decSeq -> dec . decSeq
    (76) decSeq -> . dec
    (77) decSeq -> . dec decSeq
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    $end            reduce using rule 76 (decSeq -> dec .)
    ID              shift and go to state 7
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    varDec                         shift and go to state 2
    decSeq                         shift and go to state 13
    type                           shift and go to state 4
    dec                            shift and go to state 5

state 6

    (12) type -> BOOLEAN .

    ID              reduce using rule 12 (type -> BOOLEAN .)


state 7

    (3) dec -> ID . LPAREN paramList RPAREN LKEY block RKEY

    LPAREN          shift and go to state 14
>>>>>>> master


state 8

<<<<<<< HEAD
    (11) type -> STRING .

    ID              reduce using rule 11 (type -> STRING .)
=======
    (0) S' -> program .

>>>>>>> master


state 9

<<<<<<< HEAD
    (12) type -> BOOLEAN .

    ID              reduce using rule 12 (type -> BOOLEAN .)
=======
    (11) type -> STRING .

    ID              reduce using rule 11 (type -> STRING .)
>>>>>>> master


state 10

<<<<<<< HEAD
    (77) decSeq -> dec decSeq .

    $end            reduce using rule 77 (decSeq -> dec decSeq .)
=======
    (74) varSpecSeq -> varSpec .
    (75) varSpecSeq -> varSpec . COMMA varSpecSeq

    SEMICOLON       reduce using rule 74 (varSpecSeq -> varSpec .)
    COMMA           shift and go to state 15
>>>>>>> master


state 11

<<<<<<< HEAD
    (3) dec -> ID LPAREN . paramList RPAREN LKEY block RKEY
    (68) paramList -> . paramSeq
    (69) paramList -> . empty
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    paramList                      shift and go to state 15
    paramSeq                       shift and go to state 16
    empty                          shift and go to state 17
    param                          shift and go to state 18
    type                           shift and go to state 19
=======
    (5) varDec -> type varSpecSeq . SEMICOLON

    SEMICOLON       shift and go to state 16

>>>>>>> master

state 12

    (4) dec -> type ID . LPAREN paramList RPAREN LKEY block RKEY
    (6) varSpec -> ID .
    (7) varSpec -> ID . ASSIGN literal
    (8) varSpec -> ID . LCOR NUMBER RCOR
    (9) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

<<<<<<< HEAD
    LPAREN          shift and go to state 20
    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 21
    LCOR            shift and go to state 22
=======
    LPAREN          shift and go to state 19
    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 18
    LCOR            shift and go to state 17
>>>>>>> master


state 13

<<<<<<< HEAD
    (5) varDec -> type varSpecSeq . SEMICOLON

    SEMICOLON       shift and go to state 23
=======
    (77) decSeq -> dec decSeq .

    $end            reduce using rule 77 (decSeq -> dec decSeq .)
>>>>>>> master


state 14

<<<<<<< HEAD
    (74) varSpecSeq -> varSpec .
    (75) varSpecSeq -> varSpec . COMMA varSpecSeq

    SEMICOLON       reduce using rule 74 (varSpecSeq -> varSpec .)
    COMMA           shift and go to state 24


state 15

    (3) dec -> ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 25


state 16

    (68) paramList -> paramSeq .

    RPAREN          reduce using rule 68 (paramList -> paramSeq .)
=======
    (3) dec -> ID LPAREN . paramList RPAREN LKEY block RKEY
    (68) paramList -> . paramSeq
    (69) paramList -> . empty
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    paramSeq                       shift and go to state 22
    param                          shift and go to state 20
    empty                          shift and go to state 23
    paramList                      shift and go to state 24
    type                           shift and go to state 21

state 15

    (75) varSpecSeq -> varSpec COMMA . varSpecSeq
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 26

    varSpec                        shift and go to state 10
    varSpecSeq                     shift and go to state 25

state 16

    (5) varDec -> type varSpecSeq SEMICOLON .

    ID              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    INT             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    STRING          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BOOLEAN         reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    $end            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    error           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    IF              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WHILE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    FOR             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BREAK           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RETURN          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    READ            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WRITE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RKEY            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
>>>>>>> master


state 17

<<<<<<< HEAD
    (69) paramList -> empty .

    RPAREN          reduce using rule 69 (paramList -> empty .)
=======
    (8) varSpec -> ID LCOR . NUMBER RCOR
    (9) varSpec -> ID LCOR . NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    NUMBER          shift and go to state 27
>>>>>>> master


state 18

<<<<<<< HEAD
    (70) paramSeq -> param .
    (71) paramSeq -> param . COMMA paramSeq

    RPAREN          reduce using rule 70 (paramSeq -> param .)
    COMMA           shift and go to state 26


state 19

    (13) param -> type . ID
    (14) param -> type . ID RCOR LCOR

    ID              shift and go to state 27


state 20

=======
    (7) varSpec -> ID ASSIGN . literal
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 28

state 19

>>>>>>> master
    (4) dec -> type ID LPAREN . paramList RPAREN LKEY block RKEY
    (68) paramList -> . paramSeq
    (69) paramList -> . empty
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
<<<<<<< HEAD
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    type                           shift and go to state 19
    paramList                      shift and go to state 28
    paramSeq                       shift and go to state 16
    empty                          shift and go to state 17
    param                          shift and go to state 18

state 21

    (7) varSpec -> ID ASSIGN . literal
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    literal                        shift and go to state 29

state 22

    (8) varSpec -> ID LCOR . NUMBER RCOR
    (9) varSpec -> ID LCOR . NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    NUMBER          shift and go to state 34
=======
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    paramSeq                       shift and go to state 22
    param                          shift and go to state 20
    empty                          shift and go to state 23
    paramList                      shift and go to state 33
    type                           shift and go to state 21

state 20

    (70) paramSeq -> param .
    (71) paramSeq -> param . COMMA paramSeq

    RPAREN          reduce using rule 70 (paramSeq -> param .)
    COMMA           shift and go to state 34


state 21

    (13) param -> type . ID
    (14) param -> type . ID RCOR LCOR

    ID              shift and go to state 35


state 22

    (68) paramList -> paramSeq .

    RPAREN          reduce using rule 68 (paramList -> paramSeq .)
>>>>>>> master


state 23

<<<<<<< HEAD
    (5) varDec -> type varSpecSeq SEMICOLON .

    ID              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    INT             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    STRING          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BOOLEAN         reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    $end            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    error           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    IF              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WHILE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    FOR             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BREAK           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RETURN          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    READ            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WRITE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RKEY            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
=======
    (69) paramList -> empty .

    RPAREN          reduce using rule 69 (paramList -> empty .)
>>>>>>> master


state 24

<<<<<<< HEAD
    (75) varSpecSeq -> varSpec COMMA . varSpecSeq
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 36

    varSpec                        shift and go to state 14
    varSpecSeq                     shift and go to state 35

state 25

    (3) dec -> ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 37
=======
    (3) dec -> ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 36


state 25

    (75) varSpecSeq -> varSpec COMMA varSpecSeq .

    SEMICOLON       reduce using rule 75 (varSpecSeq -> varSpec COMMA varSpecSeq .)
>>>>>>> master


state 26

<<<<<<< HEAD
    (71) paramSeq -> param COMMA . paramSeq
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    param                          shift and go to state 18
    paramSeq                       shift and go to state 38
    type                           shift and go to state 19

state 27

    (13) param -> type ID .
    (14) param -> type ID . RCOR LCOR

    COMMA           reduce using rule 13 (param -> type ID .)
    RPAREN          reduce using rule 13 (param -> type ID .)
    RCOR            shift and go to state 39
=======
    (6) varSpec -> ID .
    (7) varSpec -> ID . ASSIGN literal
    (8) varSpec -> ID . LCOR NUMBER RCOR
    (9) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 18
    LCOR            shift and go to state 17


state 27

    (8) varSpec -> ID LCOR NUMBER . RCOR
    (9) varSpec -> ID LCOR NUMBER . RCOR ASSIGN LKEY literalSeq RKEY

    RCOR            shift and go to state 37
>>>>>>> master


state 28

<<<<<<< HEAD
    (4) dec -> type ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 40


state 29

=======
>>>>>>> master
    (7) varSpec -> ID ASSIGN literal .

    COMMA           reduce using rule 7 (varSpec -> ID ASSIGN literal .)
    SEMICOLON       reduce using rule 7 (varSpec -> ID ASSIGN literal .)


<<<<<<< HEAD
state 30

    (64) literal -> NUMBER .

    COMMA           reduce using rule 64 (literal -> NUMBER .)
    SEMICOLON       reduce using rule 64 (literal -> NUMBER .)
    PLUS            reduce using rule 64 (literal -> NUMBER .)
    MINUS           reduce using rule 64 (literal -> NUMBER .)
    MULT            reduce using rule 64 (literal -> NUMBER .)
    DIVIDE          reduce using rule 64 (literal -> NUMBER .)
    MOD             reduce using rule 64 (literal -> NUMBER .)
    EQUALS          reduce using rule 64 (literal -> NUMBER .)
    DIFFERENT       reduce using rule 64 (literal -> NUMBER .)
    GT              reduce using rule 64 (literal -> NUMBER .)
    GTE             reduce using rule 64 (literal -> NUMBER .)
    LT              reduce using rule 64 (literal -> NUMBER .)
    LTE             reduce using rule 64 (literal -> NUMBER .)
    AND             reduce using rule 64 (literal -> NUMBER .)
    OR              reduce using rule 64 (literal -> NUMBER .)
    QMARK           reduce using rule 64 (literal -> NUMBER .)
    RKEY            reduce using rule 64 (literal -> NUMBER .)
    RPAREN          reduce using rule 64 (literal -> NUMBER .)
    RCOR            reduce using rule 64 (literal -> NUMBER .)
    COLON           reduce using rule 64 (literal -> NUMBER .)


state 31
=======
state 29
>>>>>>> master

    (65) literal -> STRING_LITERAL .

    COMMA           reduce using rule 65 (literal -> STRING_LITERAL .)
<<<<<<< HEAD
    SEMICOLON       reduce using rule 65 (literal -> STRING_LITERAL .)
=======
    RKEY            reduce using rule 65 (literal -> STRING_LITERAL .)
>>>>>>> master
    PLUS            reduce using rule 65 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 65 (literal -> STRING_LITERAL .)
    MULT            reduce using rule 65 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 65 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 65 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 65 (literal -> STRING_LITERAL .)
    DIFFERENT       reduce using rule 65 (literal -> STRING_LITERAL .)
    GT              reduce using rule 65 (literal -> STRING_LITERAL .)
    GTE             reduce using rule 65 (literal -> STRING_LITERAL .)
    LT              reduce using rule 65 (literal -> STRING_LITERAL .)
    LTE             reduce using rule 65 (literal -> STRING_LITERAL .)
    AND             reduce using rule 65 (literal -> STRING_LITERAL .)
    OR              reduce using rule 65 (literal -> STRING_LITERAL .)
    QMARK           reduce using rule 65 (literal -> STRING_LITERAL .)
<<<<<<< HEAD
    RKEY            reduce using rule 65 (literal -> STRING_LITERAL .)
=======
    SEMICOLON       reduce using rule 65 (literal -> STRING_LITERAL .)
>>>>>>> master
    RPAREN          reduce using rule 65 (literal -> STRING_LITERAL .)
    RCOR            reduce using rule 65 (literal -> STRING_LITERAL .)
    COLON           reduce using rule 65 (literal -> STRING_LITERAL .)


<<<<<<< HEAD
state 32

    (66) literal -> FALSE .

    COMMA           reduce using rule 66 (literal -> FALSE .)
    SEMICOLON       reduce using rule 66 (literal -> FALSE .)
=======
state 30

    (67) literal -> TRUE .

    COMMA           reduce using rule 67 (literal -> TRUE .)
    RKEY            reduce using rule 67 (literal -> TRUE .)
    PLUS            reduce using rule 67 (literal -> TRUE .)
    MINUS           reduce using rule 67 (literal -> TRUE .)
    MULT            reduce using rule 67 (literal -> TRUE .)
    DIVIDE          reduce using rule 67 (literal -> TRUE .)
    MOD             reduce using rule 67 (literal -> TRUE .)
    EQUALS          reduce using rule 67 (literal -> TRUE .)
    DIFFERENT       reduce using rule 67 (literal -> TRUE .)
    GT              reduce using rule 67 (literal -> TRUE .)
    GTE             reduce using rule 67 (literal -> TRUE .)
    LT              reduce using rule 67 (literal -> TRUE .)
    LTE             reduce using rule 67 (literal -> TRUE .)
    AND             reduce using rule 67 (literal -> TRUE .)
    OR              reduce using rule 67 (literal -> TRUE .)
    QMARK           reduce using rule 67 (literal -> TRUE .)
    SEMICOLON       reduce using rule 67 (literal -> TRUE .)
    RPAREN          reduce using rule 67 (literal -> TRUE .)
    RCOR            reduce using rule 67 (literal -> TRUE .)
    COLON           reduce using rule 67 (literal -> TRUE .)


state 31

    (66) literal -> FALSE .

    COMMA           reduce using rule 66 (literal -> FALSE .)
    RKEY            reduce using rule 66 (literal -> FALSE .)
>>>>>>> master
    PLUS            reduce using rule 66 (literal -> FALSE .)
    MINUS           reduce using rule 66 (literal -> FALSE .)
    MULT            reduce using rule 66 (literal -> FALSE .)
    DIVIDE          reduce using rule 66 (literal -> FALSE .)
    MOD             reduce using rule 66 (literal -> FALSE .)
    EQUALS          reduce using rule 66 (literal -> FALSE .)
    DIFFERENT       reduce using rule 66 (literal -> FALSE .)
    GT              reduce using rule 66 (literal -> FALSE .)
    GTE             reduce using rule 66 (literal -> FALSE .)
    LT              reduce using rule 66 (literal -> FALSE .)
    LTE             reduce using rule 66 (literal -> FALSE .)
    AND             reduce using rule 66 (literal -> FALSE .)
    OR              reduce using rule 66 (literal -> FALSE .)
    QMARK           reduce using rule 66 (literal -> FALSE .)
<<<<<<< HEAD
    RKEY            reduce using rule 66 (literal -> FALSE .)
=======
    SEMICOLON       reduce using rule 66 (literal -> FALSE .)
>>>>>>> master
    RPAREN          reduce using rule 66 (literal -> FALSE .)
    RCOR            reduce using rule 66 (literal -> FALSE .)
    COLON           reduce using rule 66 (literal -> FALSE .)


<<<<<<< HEAD
state 33

    (67) literal -> TRUE .

    COMMA           reduce using rule 67 (literal -> TRUE .)
    SEMICOLON       reduce using rule 67 (literal -> TRUE .)
    PLUS            reduce using rule 67 (literal -> TRUE .)
    MINUS           reduce using rule 67 (literal -> TRUE .)
    MULT            reduce using rule 67 (literal -> TRUE .)
    DIVIDE          reduce using rule 67 (literal -> TRUE .)
    MOD             reduce using rule 67 (literal -> TRUE .)
    EQUALS          reduce using rule 67 (literal -> TRUE .)
    DIFFERENT       reduce using rule 67 (literal -> TRUE .)
    GT              reduce using rule 67 (literal -> TRUE .)
    GTE             reduce using rule 67 (literal -> TRUE .)
    LT              reduce using rule 67 (literal -> TRUE .)
    LTE             reduce using rule 67 (literal -> TRUE .)
    AND             reduce using rule 67 (literal -> TRUE .)
    OR              reduce using rule 67 (literal -> TRUE .)
    QMARK           reduce using rule 67 (literal -> TRUE .)
    RKEY            reduce using rule 67 (literal -> TRUE .)
    RPAREN          reduce using rule 67 (literal -> TRUE .)
    RCOR            reduce using rule 67 (literal -> TRUE .)
    COLON           reduce using rule 67 (literal -> TRUE .)
=======
state 32

    (64) literal -> NUMBER .

    COMMA           reduce using rule 64 (literal -> NUMBER .)
    RKEY            reduce using rule 64 (literal -> NUMBER .)
    PLUS            reduce using rule 64 (literal -> NUMBER .)
    MINUS           reduce using rule 64 (literal -> NUMBER .)
    MULT            reduce using rule 64 (literal -> NUMBER .)
    DIVIDE          reduce using rule 64 (literal -> NUMBER .)
    MOD             reduce using rule 64 (literal -> NUMBER .)
    EQUALS          reduce using rule 64 (literal -> NUMBER .)
    DIFFERENT       reduce using rule 64 (literal -> NUMBER .)
    GT              reduce using rule 64 (literal -> NUMBER .)
    GTE             reduce using rule 64 (literal -> NUMBER .)
    LT              reduce using rule 64 (literal -> NUMBER .)
    LTE             reduce using rule 64 (literal -> NUMBER .)
    AND             reduce using rule 64 (literal -> NUMBER .)
    OR              reduce using rule 64 (literal -> NUMBER .)
    QMARK           reduce using rule 64 (literal -> NUMBER .)
    SEMICOLON       reduce using rule 64 (literal -> NUMBER .)
    RPAREN          reduce using rule 64 (literal -> NUMBER .)
    RCOR            reduce using rule 64 (literal -> NUMBER .)
    COLON           reduce using rule 64 (literal -> NUMBER .)


state 33

    (4) dec -> type ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 38
>>>>>>> master


state 34

<<<<<<< HEAD
    (8) varSpec -> ID LCOR NUMBER . RCOR
    (9) varSpec -> ID LCOR NUMBER . RCOR ASSIGN LKEY literalSeq RKEY

    RCOR            shift and go to state 41


state 35

    (75) varSpecSeq -> varSpec COMMA varSpecSeq .

    SEMICOLON       reduce using rule 75 (varSpecSeq -> varSpec COMMA varSpecSeq .)
=======
    (71) paramSeq -> param COMMA . paramSeq
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    paramSeq                       shift and go to state 39
    param                          shift and go to state 20
    type                           shift and go to state 21

state 35

    (13) param -> type ID .
    (14) param -> type ID . RCOR LCOR

    COMMA           reduce using rule 13 (param -> type ID .)
    RPAREN          reduce using rule 13 (param -> type ID .)
    RCOR            shift and go to state 40
>>>>>>> master


state 36

<<<<<<< HEAD
    (6) varSpec -> ID .
    (7) varSpec -> ID . ASSIGN literal
    (8) varSpec -> ID . LCOR NUMBER RCOR
    (9) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 21
    LCOR            shift and go to state 22
=======
    (3) dec -> ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 41
>>>>>>> master


state 37

<<<<<<< HEAD
=======
    (8) varSpec -> ID LCOR NUMBER RCOR .
    (9) varSpec -> ID LCOR NUMBER RCOR . ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 8 (varSpec -> ID LCOR NUMBER RCOR .)
    SEMICOLON       reduce using rule 8 (varSpec -> ID LCOR NUMBER RCOR .)
    ASSIGN          shift and go to state 42


state 38

    (4) dec -> type ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 43


state 39

    (71) paramSeq -> param COMMA paramSeq .

    RPAREN          reduce using rule 71 (paramSeq -> param COMMA paramSeq .)


state 40

    (14) param -> type ID RCOR . LCOR

    LCOR            shift and go to state 44


state 41

>>>>>>> master
    (3) dec -> ID LPAREN paramList RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
<<<<<<< HEAD
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 42
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 38

    (71) paramSeq -> param COMMA paramSeq .

    RPAREN          reduce using rule 71 (paramSeq -> param COMMA paramSeq .)


state 39

    (14) param -> type ID RCOR . LCOR

    LCOR            shift and go to state 47


state 40

    (4) dec -> type ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 48


state 41

    (8) varSpec -> ID LCOR NUMBER RCOR .
    (9) varSpec -> ID LCOR NUMBER RCOR . ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 8 (varSpec -> ID LCOR NUMBER RCOR .)
    SEMICOLON       reduce using rule 8 (varSpec -> ID LCOR NUMBER RCOR .)
    ASSIGN          shift and go to state 49


state 42

    (3) dec -> ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 50


state 43
=======
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    empty                          shift and go to state 49
    block                          shift and go to state 45
    varDec                         shift and go to state 46
    type                           shift and go to state 47
    varDecList                     shift and go to state 48

state 42

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN . LKEY literalSeq RKEY

    LKEY            shift and go to state 50


state 43

    (4) dec -> type ID LPAREN paramList RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    empty                          shift and go to state 49
    block                          shift and go to state 51
    varDec                         shift and go to state 46
    type                           shift and go to state 47
    varDecList                     shift and go to state 48

state 44

    (14) param -> type ID RCOR LCOR .

    COMMA           reduce using rule 14 (param -> type ID RCOR LCOR .)
    RPAREN          reduce using rule 14 (param -> type ID RCOR LCOR .)


state 45

    (3) dec -> ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 52


state 46

    (72) varDecList -> varDec . varDecList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    varDec                         shift and go to state 46
    empty                          shift and go to state 49
    type                           shift and go to state 47
    varDecList                     shift and go to state 53

state 47

    (5) varDec -> type . varSpecSeq SEMICOLON
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 26

    varSpec                        shift and go to state 10
    varSpecSeq                     shift and go to state 11

state 48
>>>>>>> master

    (15) block -> varDecList . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (25) stmt -> . error
    (86) empty -> .
    (26) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (27) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (28) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (29) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (30) breakStmt -> . BREAK SEMICOLON
    (33) returnStmt -> . RETURN SEMICOLON
    (34) returnStmt -> . RETURN exp SEMICOLON
    (31) readStmt -> . READ var SEMICOLON
    (32) writeStmt -> . WRITE expList SEMICOLON
    (36) assign -> . var ASSIGN exp
    (37) assign -> . var PLUSASSIGN exp
    (38) assign -> . var MINUSASSIGN exp
    (39) assign -> . var MULTASSIGN exp
    (40) assign -> . var DIVIDEASSIGN exp
    (41) assign -> . var MODASSIGN exp
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

<<<<<<< HEAD
    error           shift and go to state 63
    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    BREAK           shift and go to state 67
    RETURN          shift and go to state 68
    READ            shift and go to state 69
    WRITE           shift and go to state 71
    ID              shift and go to state 72

    stmtList                       shift and go to state 51
    stmt                           shift and go to state 52
    empty                          shift and go to state 53
    ifStmt                         shift and go to state 54
    whileStmt                      shift and go to state 55
    forStmt                        shift and go to state 56
    breakStmt                      shift and go to state 57
    returnStmt                     shift and go to state 58
    readStmt                       shift and go to state 59
    writeStmt                      shift and go to state 60
    assign                         shift and go to state 61
    subCall                        shift and go to state 62
    var                            shift and go to state 70

state 44

    (72) varDecList -> varDec . varDecList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    varDec                         shift and go to state 44
    varDecList                     shift and go to state 73
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 45
=======
    error           shift and go to state 55
    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 74
    WHILE           shift and go to state 54
    FOR             shift and go to state 56
    BREAK           shift and go to state 75
    RETURN          shift and go to state 57
    READ            shift and go to state 73
    WRITE           shift and go to state 61
    ID              shift and go to state 62

    assign                         shift and go to state 64
    subCall                        shift and go to state 58
    forStmt                        shift and go to state 66
    stmtList                       shift and go to state 67
    writeStmt                      shift and go to state 71
    returnStmt                     shift and go to state 70
    empty                          shift and go to state 72
    breakStmt                      shift and go to state 68
    stmt                           shift and go to state 65
    readStmt                       shift and go to state 59
    ifStmt                         shift and go to state 60
    whileStmt                      shift and go to state 63
    var                            shift and go to state 69

state 49
>>>>>>> master

    (73) varDecList -> empty .

    error           reduce using rule 73 (varDecList -> empty .)
    IF              reduce using rule 73 (varDecList -> empty .)
    WHILE           reduce using rule 73 (varDecList -> empty .)
    FOR             reduce using rule 73 (varDecList -> empty .)
    BREAK           reduce using rule 73 (varDecList -> empty .)
    RETURN          reduce using rule 73 (varDecList -> empty .)
    READ            reduce using rule 73 (varDecList -> empty .)
    WRITE           reduce using rule 73 (varDecList -> empty .)
    ID              reduce using rule 73 (varDecList -> empty .)
    RKEY            reduce using rule 73 (varDecList -> empty .)


<<<<<<< HEAD
state 46

    (5) varDec -> type . varSpecSeq SEMICOLON
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 36

    varSpecSeq                     shift and go to state 13
    varSpec                        shift and go to state 14

state 47

    (14) param -> type ID RCOR LCOR .

    COMMA           reduce using rule 14 (param -> type ID RCOR LCOR .)
    RPAREN          reduce using rule 14 (param -> type ID RCOR LCOR .)


state 48

    (4) dec -> type ID LPAREN paramList RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    type                           shift and go to state 46
    block                          shift and go to state 74
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45

state 49

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN . LKEY literalSeq RKEY

    LKEY            shift and go to state 75


state 50
=======
state 50

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY . literalSeq RKEY
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 76
    literalSeq                     shift and go to state 77

state 51

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 78


state 52
>>>>>>> master

    (3) dec -> ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)


<<<<<<< HEAD
state 51

    (15) block -> varDecList stmtList .

    RKEY            reduce using rule 15 (block -> varDecList stmtList .)


state 52

    (78) stmtList -> stmt . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (25) stmt -> . error
    (86) empty -> .
    (26) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (27) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (28) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (29) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (30) breakStmt -> . BREAK SEMICOLON
    (33) returnStmt -> . RETURN SEMICOLON
    (34) returnStmt -> . RETURN exp SEMICOLON
    (31) readStmt -> . READ var SEMICOLON
    (32) writeStmt -> . WRITE expList SEMICOLON
    (36) assign -> . var ASSIGN exp
    (37) assign -> . var PLUSASSIGN exp
    (38) assign -> . var MINUSASSIGN exp
    (39) assign -> . var MULTASSIGN exp
    (40) assign -> . var DIVIDEASSIGN exp
    (41) assign -> . var MODASSIGN exp
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

    error           shift and go to state 63
    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    BREAK           shift and go to state 67
    RETURN          shift and go to state 68
    READ            shift and go to state 69
    WRITE           shift and go to state 71
    ID              shift and go to state 72

    stmt                           shift and go to state 52
    stmtList                       shift and go to state 76
    empty                          shift and go to state 53
    ifStmt                         shift and go to state 54
    whileStmt                      shift and go to state 55
    forStmt                        shift and go to state 56
    breakStmt                      shift and go to state 57
    returnStmt                     shift and go to state 58
    readStmt                       shift and go to state 59
    writeStmt                      shift and go to state 60
    assign                         shift and go to state 61
    subCall                        shift and go to state 62
    var                            shift and go to state 70

state 53

    (79) stmtList -> empty .

    RKEY            reduce using rule 79 (stmtList -> empty .)
=======
state 53

    (72) varDecList -> varDec varDecList .

    error           reduce using rule 72 (varDecList -> varDec varDecList .)
    IF              reduce using rule 72 (varDecList -> varDec varDecList .)
    WHILE           reduce using rule 72 (varDecList -> varDec varDecList .)
    FOR             reduce using rule 72 (varDecList -> varDec varDecList .)
    BREAK           reduce using rule 72 (varDecList -> varDec varDecList .)
    RETURN          reduce using rule 72 (varDecList -> varDec varDecList .)
    READ            reduce using rule 72 (varDecList -> varDec varDecList .)
    WRITE           reduce using rule 72 (varDecList -> varDec varDecList .)
    ID              reduce using rule 72 (varDecList -> varDec varDecList .)
    RKEY            reduce using rule 72 (varDecList -> varDec varDecList .)
>>>>>>> master


state 54

<<<<<<< HEAD
    (16) stmt -> ifStmt .

    error           reduce using rule 16 (stmt -> ifStmt .)
    IF              reduce using rule 16 (stmt -> ifStmt .)
    WHILE           reduce using rule 16 (stmt -> ifStmt .)
    FOR             reduce using rule 16 (stmt -> ifStmt .)
    BREAK           reduce using rule 16 (stmt -> ifStmt .)
    RETURN          reduce using rule 16 (stmt -> ifStmt .)
    READ            reduce using rule 16 (stmt -> ifStmt .)
    WRITE           reduce using rule 16 (stmt -> ifStmt .)
    ID              reduce using rule 16 (stmt -> ifStmt .)
    RKEY            reduce using rule 16 (stmt -> ifStmt .)
=======
    (28) whileStmt -> WHILE . LPAREN exp RPAREN LKEY block RKEY

    LPAREN          shift and go to state 79
>>>>>>> master


state 55

<<<<<<< HEAD
    (17) stmt -> whileStmt .

    error           reduce using rule 17 (stmt -> whileStmt .)
    IF              reduce using rule 17 (stmt -> whileStmt .)
    WHILE           reduce using rule 17 (stmt -> whileStmt .)
    FOR             reduce using rule 17 (stmt -> whileStmt .)
    BREAK           reduce using rule 17 (stmt -> whileStmt .)
    RETURN          reduce using rule 17 (stmt -> whileStmt .)
    READ            reduce using rule 17 (stmt -> whileStmt .)
    WRITE           reduce using rule 17 (stmt -> whileStmt .)
    ID              reduce using rule 17 (stmt -> whileStmt .)
    RKEY            reduce using rule 17 (stmt -> whileStmt .)
=======
    (25) stmt -> error .

    error           reduce using rule 25 (stmt -> error .)
    IF              reduce using rule 25 (stmt -> error .)
    WHILE           reduce using rule 25 (stmt -> error .)
    FOR             reduce using rule 25 (stmt -> error .)
    BREAK           reduce using rule 25 (stmt -> error .)
    RETURN          reduce using rule 25 (stmt -> error .)
    READ            reduce using rule 25 (stmt -> error .)
    WRITE           reduce using rule 25 (stmt -> error .)
    ID              reduce using rule 25 (stmt -> error .)
    RKEY            reduce using rule 25 (stmt -> error .)
>>>>>>> master


state 56

<<<<<<< HEAD
    (18) stmt -> forStmt .

    error           reduce using rule 18 (stmt -> forStmt .)
    IF              reduce using rule 18 (stmt -> forStmt .)
    WHILE           reduce using rule 18 (stmt -> forStmt .)
    FOR             reduce using rule 18 (stmt -> forStmt .)
    BREAK           reduce using rule 18 (stmt -> forStmt .)
    RETURN          reduce using rule 18 (stmt -> forStmt .)
    READ            reduce using rule 18 (stmt -> forStmt .)
    WRITE           reduce using rule 18 (stmt -> forStmt .)
    ID              reduce using rule 18 (stmt -> forStmt .)
    RKEY            reduce using rule 18 (stmt -> forStmt .)
=======
    (29) forStmt -> FOR . LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    LPAREN          shift and go to state 80
>>>>>>> master


state 57

<<<<<<< HEAD
    (19) stmt -> breakStmt .

    error           reduce using rule 19 (stmt -> breakStmt .)
    IF              reduce using rule 19 (stmt -> breakStmt .)
    WHILE           reduce using rule 19 (stmt -> breakStmt .)
    FOR             reduce using rule 19 (stmt -> breakStmt .)
    BREAK           reduce using rule 19 (stmt -> breakStmt .)
    RETURN          reduce using rule 19 (stmt -> breakStmt .)
    READ            reduce using rule 19 (stmt -> breakStmt .)
    WRITE           reduce using rule 19 (stmt -> breakStmt .)
    ID              reduce using rule 19 (stmt -> breakStmt .)
    RKEY            reduce using rule 19 (stmt -> breakStmt .)


state 58

    (20) stmt -> returnStmt .

    error           reduce using rule 20 (stmt -> returnStmt .)
    IF              reduce using rule 20 (stmt -> returnStmt .)
    WHILE           reduce using rule 20 (stmt -> returnStmt .)
    FOR             reduce using rule 20 (stmt -> returnStmt .)
    BREAK           reduce using rule 20 (stmt -> returnStmt .)
    RETURN          reduce using rule 20 (stmt -> returnStmt .)
    READ            reduce using rule 20 (stmt -> returnStmt .)
    WRITE           reduce using rule 20 (stmt -> returnStmt .)
    ID              reduce using rule 20 (stmt -> returnStmt .)
    RKEY            reduce using rule 20 (stmt -> returnStmt .)
=======
    (33) returnStmt -> RETURN . SEMICOLON
    (34) returnStmt -> RETURN . exp SEMICOLON
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    SEMICOLON       shift and go to state 88
    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 87
    var                            shift and go to state 84

state 58

    (24) stmt -> subCall . SEMICOLON

    SEMICOLON       shift and go to state 89
>>>>>>> master


state 59

    (21) stmt -> readStmt .

    error           reduce using rule 21 (stmt -> readStmt .)
    IF              reduce using rule 21 (stmt -> readStmt .)
    WHILE           reduce using rule 21 (stmt -> readStmt .)
    FOR             reduce using rule 21 (stmt -> readStmt .)
    BREAK           reduce using rule 21 (stmt -> readStmt .)
    RETURN          reduce using rule 21 (stmt -> readStmt .)
    READ            reduce using rule 21 (stmt -> readStmt .)
    WRITE           reduce using rule 21 (stmt -> readStmt .)
    ID              reduce using rule 21 (stmt -> readStmt .)
    RKEY            reduce using rule 21 (stmt -> readStmt .)


state 60

<<<<<<< HEAD
    (22) stmt -> writeStmt .

    error           reduce using rule 22 (stmt -> writeStmt .)
    IF              reduce using rule 22 (stmt -> writeStmt .)
    WHILE           reduce using rule 22 (stmt -> writeStmt .)
    FOR             reduce using rule 22 (stmt -> writeStmt .)
    BREAK           reduce using rule 22 (stmt -> writeStmt .)
    RETURN          reduce using rule 22 (stmt -> writeStmt .)
    READ            reduce using rule 22 (stmt -> writeStmt .)
    WRITE           reduce using rule 22 (stmt -> writeStmt .)
    ID              reduce using rule 22 (stmt -> writeStmt .)
    RKEY            reduce using rule 22 (stmt -> writeStmt .)
=======
    (16) stmt -> ifStmt .

    error           reduce using rule 16 (stmt -> ifStmt .)
    IF              reduce using rule 16 (stmt -> ifStmt .)
    WHILE           reduce using rule 16 (stmt -> ifStmt .)
    FOR             reduce using rule 16 (stmt -> ifStmt .)
    BREAK           reduce using rule 16 (stmt -> ifStmt .)
    RETURN          reduce using rule 16 (stmt -> ifStmt .)
    READ            reduce using rule 16 (stmt -> ifStmt .)
    WRITE           reduce using rule 16 (stmt -> ifStmt .)
    ID              reduce using rule 16 (stmt -> ifStmt .)
    RKEY            reduce using rule 16 (stmt -> ifStmt .)
>>>>>>> master


state 61

<<<<<<< HEAD
    (23) stmt -> assign . SEMICOLON

    SEMICOLON       shift and go to state 77


state 62

    (24) stmt -> subCall . SEMICOLON

    SEMICOLON       shift and go to state 78


state 63

    (25) stmt -> error .

    error           reduce using rule 25 (stmt -> error .)
    IF              reduce using rule 25 (stmt -> error .)
    WHILE           reduce using rule 25 (stmt -> error .)
    FOR             reduce using rule 25 (stmt -> error .)
    BREAK           reduce using rule 25 (stmt -> error .)
    RETURN          reduce using rule 25 (stmt -> error .)
    READ            reduce using rule 25 (stmt -> error .)
    WRITE           reduce using rule 25 (stmt -> error .)
    ID              reduce using rule 25 (stmt -> error .)
    RKEY            reduce using rule 25 (stmt -> error .)


state 64

    (26) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY
    (27) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY

    LPAREN          shift and go to state 79


state 65

    (28) whileStmt -> WHILE . LPAREN exp RPAREN LKEY block RKEY

    LPAREN          shift and go to state 80


state 66

    (29) forStmt -> FOR . LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    LPAREN          shift and go to state 81


state 67

    (30) breakStmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 82


state 68

    (33) returnStmt -> RETURN . SEMICOLON
    (34) returnStmt -> RETURN . exp SEMICOLON
=======
    (32) writeStmt -> WRITE . expList SEMICOLON
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

<<<<<<< HEAD
    SEMICOLON       shift and go to state 83
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 84
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 69

    (31) readStmt -> READ . var SEMICOLON
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    var                            shift and go to state 91

state 70
=======
    SEMICOLON       reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 86
    expList                        shift and go to state 90
    empty                          shift and go to state 91
    exp                            shift and go to state 92
    subCall                        shift and go to state 81
    expSeq                         shift and go to state 93
    var                            shift and go to state 84

state 62

    (35) subCall -> ID . LPAREN expList RPAREN
    (62) var -> ID .
    (63) var -> ID . LCOR exp RCOR

    LPAREN          shift and go to state 95
    PLUS            reduce using rule 62 (var -> ID .)
    MINUS           reduce using rule 62 (var -> ID .)
    MULT            reduce using rule 62 (var -> ID .)
    DIVIDE          reduce using rule 62 (var -> ID .)
    MOD             reduce using rule 62 (var -> ID .)
    EQUALS          reduce using rule 62 (var -> ID .)
    DIFFERENT       reduce using rule 62 (var -> ID .)
    GT              reduce using rule 62 (var -> ID .)
    GTE             reduce using rule 62 (var -> ID .)
    LT              reduce using rule 62 (var -> ID .)
    LTE             reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    QMARK           reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)
    COMMA           reduce using rule 62 (var -> ID .)
    RPAREN          reduce using rule 62 (var -> ID .)
    RCOR            reduce using rule 62 (var -> ID .)
    COLON           reduce using rule 62 (var -> ID .)
    ASSIGN          reduce using rule 62 (var -> ID .)
    PLUSASSIGN      reduce using rule 62 (var -> ID .)
    MINUSASSIGN     reduce using rule 62 (var -> ID .)
    MULTASSIGN      reduce using rule 62 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 62 (var -> ID .)
    MODASSIGN       reduce using rule 62 (var -> ID .)
    LCOR            shift and go to state 94


state 63

    (17) stmt -> whileStmt .

    error           reduce using rule 17 (stmt -> whileStmt .)
    IF              reduce using rule 17 (stmt -> whileStmt .)
    WHILE           reduce using rule 17 (stmt -> whileStmt .)
    FOR             reduce using rule 17 (stmt -> whileStmt .)
    BREAK           reduce using rule 17 (stmt -> whileStmt .)
    RETURN          reduce using rule 17 (stmt -> whileStmt .)
    READ            reduce using rule 17 (stmt -> whileStmt .)
    WRITE           reduce using rule 17 (stmt -> whileStmt .)
    ID              reduce using rule 17 (stmt -> whileStmt .)
    RKEY            reduce using rule 17 (stmt -> whileStmt .)


state 64

    (23) stmt -> assign . SEMICOLON

    SEMICOLON       shift and go to state 96


state 65

    (78) stmtList -> stmt . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (25) stmt -> . error
    (86) empty -> .
    (26) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (27) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (28) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (29) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (30) breakStmt -> . BREAK SEMICOLON
    (33) returnStmt -> . RETURN SEMICOLON
    (34) returnStmt -> . RETURN exp SEMICOLON
    (31) readStmt -> . READ var SEMICOLON
    (32) writeStmt -> . WRITE expList SEMICOLON
    (36) assign -> . var ASSIGN exp
    (37) assign -> . var PLUSASSIGN exp
    (38) assign -> . var MINUSASSIGN exp
    (39) assign -> . var MULTASSIGN exp
    (40) assign -> . var DIVIDEASSIGN exp
    (41) assign -> . var MODASSIGN exp
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

    error           shift and go to state 55
    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 74
    WHILE           shift and go to state 54
    FOR             shift and go to state 56
    BREAK           shift and go to state 75
    RETURN          shift and go to state 57
    READ            shift and go to state 73
    WRITE           shift and go to state 61
    ID              shift and go to state 62

    assign                         shift and go to state 64
    subCall                        shift and go to state 58
    forStmt                        shift and go to state 66
    stmtList                       shift and go to state 97
    writeStmt                      shift and go to state 71
    ifStmt                         shift and go to state 60
    returnStmt                     shift and go to state 70
    empty                          shift and go to state 72
    breakStmt                      shift and go to state 68
    stmt                           shift and go to state 65
    readStmt                       shift and go to state 59
    var                            shift and go to state 69
    whileStmt                      shift and go to state 63

state 66

    (18) stmt -> forStmt .

    error           reduce using rule 18 (stmt -> forStmt .)
    IF              reduce using rule 18 (stmt -> forStmt .)
    WHILE           reduce using rule 18 (stmt -> forStmt .)
    FOR             reduce using rule 18 (stmt -> forStmt .)
    BREAK           reduce using rule 18 (stmt -> forStmt .)
    RETURN          reduce using rule 18 (stmt -> forStmt .)
    READ            reduce using rule 18 (stmt -> forStmt .)
    WRITE           reduce using rule 18 (stmt -> forStmt .)
    ID              reduce using rule 18 (stmt -> forStmt .)
    RKEY            reduce using rule 18 (stmt -> forStmt .)


state 67

    (15) block -> varDecList stmtList .

    RKEY            reduce using rule 15 (block -> varDecList stmtList .)


state 68

    (19) stmt -> breakStmt .

    error           reduce using rule 19 (stmt -> breakStmt .)
    IF              reduce using rule 19 (stmt -> breakStmt .)
    WHILE           reduce using rule 19 (stmt -> breakStmt .)
    FOR             reduce using rule 19 (stmt -> breakStmt .)
    BREAK           reduce using rule 19 (stmt -> breakStmt .)
    RETURN          reduce using rule 19 (stmt -> breakStmt .)
    READ            reduce using rule 19 (stmt -> breakStmt .)
    WRITE           reduce using rule 19 (stmt -> breakStmt .)
    ID              reduce using rule 19 (stmt -> breakStmt .)
    RKEY            reduce using rule 19 (stmt -> breakStmt .)


state 69
>>>>>>> master

    (36) assign -> var . ASSIGN exp
    (37) assign -> var . PLUSASSIGN exp
    (38) assign -> var . MINUSASSIGN exp
    (39) assign -> var . MULTASSIGN exp
    (40) assign -> var . DIVIDEASSIGN exp
    (41) assign -> var . MODASSIGN exp

<<<<<<< HEAD
    ASSIGN          shift and go to state 93
    PLUSASSIGN      shift and go to state 94
    MINUSASSIGN     shift and go to state 95
    MULTASSIGN      shift and go to state 96
    DIVIDEASSIGN    shift and go to state 97
    MODASSIGN       shift and go to state 98
=======
    ASSIGN          shift and go to state 99
    PLUSASSIGN      shift and go to state 103
    MINUSASSIGN     shift and go to state 98
    MULTASSIGN      shift and go to state 102
    DIVIDEASSIGN    shift and go to state 101
    MODASSIGN       shift and go to state 100


state 70

    (20) stmt -> returnStmt .

    error           reduce using rule 20 (stmt -> returnStmt .)
    IF              reduce using rule 20 (stmt -> returnStmt .)
    WHILE           reduce using rule 20 (stmt -> returnStmt .)
    FOR             reduce using rule 20 (stmt -> returnStmt .)
    BREAK           reduce using rule 20 (stmt -> returnStmt .)
    RETURN          reduce using rule 20 (stmt -> returnStmt .)
    READ            reduce using rule 20 (stmt -> returnStmt .)
    WRITE           reduce using rule 20 (stmt -> returnStmt .)
    ID              reduce using rule 20 (stmt -> returnStmt .)
    RKEY            reduce using rule 20 (stmt -> returnStmt .)
>>>>>>> master


state 71

<<<<<<< HEAD
    (32) writeStmt -> WRITE . expList SEMICOLON
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    SEMICOLON       reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    expList                        shift and go to state 99
    expSeq                         shift and go to state 100
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 72

    (35) subCall -> ID . LPAREN expList RPAREN
    (62) var -> ID .
    (63) var -> ID . LCOR exp RCOR

    LPAREN          shift and go to state 103
    ASSIGN          reduce using rule 62 (var -> ID .)
    PLUSASSIGN      reduce using rule 62 (var -> ID .)
    MINUSASSIGN     reduce using rule 62 (var -> ID .)
    MULTASSIGN      reduce using rule 62 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 62 (var -> ID .)
    MODASSIGN       reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)
    PLUS            reduce using rule 62 (var -> ID .)
    MINUS           reduce using rule 62 (var -> ID .)
    MULT            reduce using rule 62 (var -> ID .)
    DIVIDE          reduce using rule 62 (var -> ID .)
    MOD             reduce using rule 62 (var -> ID .)
    EQUALS          reduce using rule 62 (var -> ID .)
    DIFFERENT       reduce using rule 62 (var -> ID .)
    GT              reduce using rule 62 (var -> ID .)
    GTE             reduce using rule 62 (var -> ID .)
    LT              reduce using rule 62 (var -> ID .)
    LTE             reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    QMARK           reduce using rule 62 (var -> ID .)
    COMMA           reduce using rule 62 (var -> ID .)
    RPAREN          reduce using rule 62 (var -> ID .)
    RCOR            reduce using rule 62 (var -> ID .)
    COLON           reduce using rule 62 (var -> ID .)
    LCOR            shift and go to state 104
=======
    (22) stmt -> writeStmt .

    error           reduce using rule 22 (stmt -> writeStmt .)
    IF              reduce using rule 22 (stmt -> writeStmt .)
    WHILE           reduce using rule 22 (stmt -> writeStmt .)
    FOR             reduce using rule 22 (stmt -> writeStmt .)
    BREAK           reduce using rule 22 (stmt -> writeStmt .)
    RETURN          reduce using rule 22 (stmt -> writeStmt .)
    READ            reduce using rule 22 (stmt -> writeStmt .)
    WRITE           reduce using rule 22 (stmt -> writeStmt .)
    ID              reduce using rule 22 (stmt -> writeStmt .)
    RKEY            reduce using rule 22 (stmt -> writeStmt .)


state 72

    (79) stmtList -> empty .

    RKEY            reduce using rule 79 (stmtList -> empty .)
>>>>>>> master


state 73

<<<<<<< HEAD
    (72) varDecList -> varDec varDecList .

    error           reduce using rule 72 (varDecList -> varDec varDecList .)
    IF              reduce using rule 72 (varDecList -> varDec varDecList .)
    WHILE           reduce using rule 72 (varDecList -> varDec varDecList .)
    FOR             reduce using rule 72 (varDecList -> varDec varDecList .)
    BREAK           reduce using rule 72 (varDecList -> varDec varDecList .)
    RETURN          reduce using rule 72 (varDecList -> varDec varDecList .)
    READ            reduce using rule 72 (varDecList -> varDec varDecList .)
    WRITE           reduce using rule 72 (varDecList -> varDec varDecList .)
    ID              reduce using rule 72 (varDecList -> varDec varDecList .)
    RKEY            reduce using rule 72 (varDecList -> varDec varDecList .)


state 74

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 105
=======
    (31) readStmt -> READ . var SEMICOLON
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

    ID              shift and go to state 104

    var                            shift and go to state 105

state 74

    (26) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY
    (27) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY

    LPAREN          shift and go to state 106
>>>>>>> master


state 75

<<<<<<< HEAD
    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY . literalSeq RKEY
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    literalSeq                     shift and go to state 106
    literal                        shift and go to state 107

state 76

    (78) stmtList -> stmt stmtList .

    RKEY            reduce using rule 78 (stmtList -> stmt stmtList .)
=======
    (30) breakStmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 107


state 76

    (80) literalSeq -> literal .
    (81) literalSeq -> literal . COMMA literalSeq

    RKEY            reduce using rule 80 (literalSeq -> literal .)
    COMMA           shift and go to state 108
>>>>>>> master


state 77

<<<<<<< HEAD
    (23) stmt -> assign SEMICOLON .

    error           reduce using rule 23 (stmt -> assign SEMICOLON .)
    IF              reduce using rule 23 (stmt -> assign SEMICOLON .)
    WHILE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    FOR             reduce using rule 23 (stmt -> assign SEMICOLON .)
    BREAK           reduce using rule 23 (stmt -> assign SEMICOLON .)
    RETURN          reduce using rule 23 (stmt -> assign SEMICOLON .)
    READ            reduce using rule 23 (stmt -> assign SEMICOLON .)
    WRITE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    ID              reduce using rule 23 (stmt -> assign SEMICOLON .)
    RKEY            reduce using rule 23 (stmt -> assign SEMICOLON .)
=======
    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq . RKEY

    RKEY            shift and go to state 109
>>>>>>> master


state 78

<<<<<<< HEAD
    (24) stmt -> subCall SEMICOLON .

    error           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    IF              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    FOR             reduce using rule 24 (stmt -> subCall SEMICOLON .)
    BREAK           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RETURN          reduce using rule 24 (stmt -> subCall SEMICOLON .)
    READ            reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WRITE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    ID              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RKEY            reduce using rule 24 (stmt -> subCall SEMICOLON .)
=======
    (4) dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
>>>>>>> master


state 79

<<<<<<< HEAD
    (26) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY
    (27) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 108
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 80

=======
>>>>>>> master
    (28) whileStmt -> WHILE LPAREN . exp RPAREN LKEY block RKEY
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 109
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 81

    (29) forStmt -> FOR LPAREN . assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (36) assign -> . var ASSIGN exp
    (37) assign -> . var PLUSASSIGN exp
    (38) assign -> . var MINUSASSIGN exp
    (39) assign -> . var MULTASSIGN exp
    (40) assign -> . var DIVIDEASSIGN exp
    (41) assign -> . var MODASSIGN exp
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    assign                         shift and go to state 110
    var                            shift and go to state 70

state 82

    (30) breakStmt -> BREAK SEMICOLON .

    error           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    IF              reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    READ            reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    WRITE           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    ID              reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    RKEY            reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)


state 83

    (33) returnStmt -> RETURN SEMICOLON .

    error           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    IF              reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    READ            reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    WRITE           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    ID              reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    RKEY            reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)


state 84

    (34) returnStmt -> RETURN exp . SEMICOLON
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

    SEMICOLON       shift and go to state 111
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 85

    (55) exp -> NOT . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 86
    exp                            shift and go to state 110
    subCall                        shift and go to state 81
    var                            shift and go to state 84

state 80

    (29) forStmt -> FOR LPAREN . assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (36) assign -> . var ASSIGN exp
    (37) assign -> . var PLUSASSIGN exp
    (38) assign -> . var MINUSASSIGN exp
    (39) assign -> . var MULTASSIGN exp
    (40) assign -> . var DIVIDEASSIGN exp
    (41) assign -> . var MODASSIGN exp
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

    ID              shift and go to state 104

    assign                         shift and go to state 111
    var                            shift and go to state 69

state 81

    (58) exp -> subCall .

    COMMA           reduce using rule 58 (exp -> subCall .)
    PLUS            reduce using rule 58 (exp -> subCall .)
    MINUS           reduce using rule 58 (exp -> subCall .)
    MULT            reduce using rule 58 (exp -> subCall .)
    DIVIDE          reduce using rule 58 (exp -> subCall .)
    MOD             reduce using rule 58 (exp -> subCall .)
    EQUALS          reduce using rule 58 (exp -> subCall .)
    DIFFERENT       reduce using rule 58 (exp -> subCall .)
    GT              reduce using rule 58 (exp -> subCall .)
    GTE             reduce using rule 58 (exp -> subCall .)
    LT              reduce using rule 58 (exp -> subCall .)
    LTE             reduce using rule 58 (exp -> subCall .)
    AND             reduce using rule 58 (exp -> subCall .)
    OR              reduce using rule 58 (exp -> subCall .)
    QMARK           reduce using rule 58 (exp -> subCall .)
    RPAREN          reduce using rule 58 (exp -> subCall .)
    SEMICOLON       reduce using rule 58 (exp -> subCall .)
    RCOR            reduce using rule 58 (exp -> subCall .)
    COLON           reduce using rule 58 (exp -> subCall .)


state 82

    (61) exp -> LPAREN . exp RPAREN
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 126
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 86
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 112
    var                            shift and go to state 84

state 83
>>>>>>> master

    (56) exp -> UMINUS . exp
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 127
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 87

    (58) exp -> subCall .

    SEMICOLON       reduce using rule 58 (exp -> subCall .)
    PLUS            reduce using rule 58 (exp -> subCall .)
    MINUS           reduce using rule 58 (exp -> subCall .)
    MULT            reduce using rule 58 (exp -> subCall .)
    DIVIDE          reduce using rule 58 (exp -> subCall .)
    MOD             reduce using rule 58 (exp -> subCall .)
    EQUALS          reduce using rule 58 (exp -> subCall .)
    DIFFERENT       reduce using rule 58 (exp -> subCall .)
    GT              reduce using rule 58 (exp -> subCall .)
    GTE             reduce using rule 58 (exp -> subCall .)
    LT              reduce using rule 58 (exp -> subCall .)
    LTE             reduce using rule 58 (exp -> subCall .)
    AND             reduce using rule 58 (exp -> subCall .)
    OR              reduce using rule 58 (exp -> subCall .)
    QMARK           reduce using rule 58 (exp -> subCall .)
    COMMA           reduce using rule 58 (exp -> subCall .)
    RPAREN          reduce using rule 58 (exp -> subCall .)
    RCOR            reduce using rule 58 (exp -> subCall .)
    COLON           reduce using rule 58 (exp -> subCall .)


state 88

    (59) exp -> var .

    SEMICOLON       reduce using rule 59 (exp -> var .)
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 113
    var                            shift and go to state 84

state 84

    (59) exp -> var .

    COMMA           reduce using rule 59 (exp -> var .)
>>>>>>> master
    PLUS            reduce using rule 59 (exp -> var .)
    MINUS           reduce using rule 59 (exp -> var .)
    MULT            reduce using rule 59 (exp -> var .)
    DIVIDE          reduce using rule 59 (exp -> var .)
    MOD             reduce using rule 59 (exp -> var .)
    EQUALS          reduce using rule 59 (exp -> var .)
    DIFFERENT       reduce using rule 59 (exp -> var .)
    GT              reduce using rule 59 (exp -> var .)
    GTE             reduce using rule 59 (exp -> var .)
    LT              reduce using rule 59 (exp -> var .)
    LTE             reduce using rule 59 (exp -> var .)
    AND             reduce using rule 59 (exp -> var .)
    OR              reduce using rule 59 (exp -> var .)
    QMARK           reduce using rule 59 (exp -> var .)
<<<<<<< HEAD
    COMMA           reduce using rule 59 (exp -> var .)
    RPAREN          reduce using rule 59 (exp -> var .)
=======
    RPAREN          reduce using rule 59 (exp -> var .)
    SEMICOLON       reduce using rule 59 (exp -> var .)
>>>>>>> master
    RCOR            reduce using rule 59 (exp -> var .)
    COLON           reduce using rule 59 (exp -> var .)


<<<<<<< HEAD
state 89

    (60) exp -> literal .

    SEMICOLON       reduce using rule 60 (exp -> literal .)
=======
state 85

    (55) exp -> NOT . exp
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 114
    var                            shift and go to state 84

state 86

    (60) exp -> literal .

    COMMA           reduce using rule 60 (exp -> literal .)
>>>>>>> master
    PLUS            reduce using rule 60 (exp -> literal .)
    MINUS           reduce using rule 60 (exp -> literal .)
    MULT            reduce using rule 60 (exp -> literal .)
    DIVIDE          reduce using rule 60 (exp -> literal .)
    MOD             reduce using rule 60 (exp -> literal .)
    EQUALS          reduce using rule 60 (exp -> literal .)
    DIFFERENT       reduce using rule 60 (exp -> literal .)
    GT              reduce using rule 60 (exp -> literal .)
    GTE             reduce using rule 60 (exp -> literal .)
    LT              reduce using rule 60 (exp -> literal .)
    LTE             reduce using rule 60 (exp -> literal .)
    AND             reduce using rule 60 (exp -> literal .)
    OR              reduce using rule 60 (exp -> literal .)
    QMARK           reduce using rule 60 (exp -> literal .)
<<<<<<< HEAD
    COMMA           reduce using rule 60 (exp -> literal .)
    RPAREN          reduce using rule 60 (exp -> literal .)
=======
    RPAREN          reduce using rule 60 (exp -> literal .)
    SEMICOLON       reduce using rule 60 (exp -> literal .)
>>>>>>> master
    RCOR            reduce using rule 60 (exp -> literal .)
    COLON           reduce using rule 60 (exp -> literal .)


<<<<<<< HEAD
state 90

    (61) exp -> LPAREN . exp RPAREN
=======
state 87

    (34) returnStmt -> RETURN exp . SEMICOLON
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

    SEMICOLON       shift and go to state 120
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 88

    (33) returnStmt -> RETURN SEMICOLON .

    error           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    IF              reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    READ            reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    WRITE           reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    ID              reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)
    RKEY            reduce using rule 33 (returnStmt -> RETURN SEMICOLON .)


state 89

    (24) stmt -> subCall SEMICOLON .

    error           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    IF              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    FOR             reduce using rule 24 (stmt -> subCall SEMICOLON .)
    BREAK           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RETURN          reduce using rule 24 (stmt -> subCall SEMICOLON .)
    READ            reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WRITE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    ID              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RKEY            reduce using rule 24 (stmt -> subCall SEMICOLON .)


state 90

    (32) writeStmt -> WRITE expList . SEMICOLON

    SEMICOLON       shift and go to state 130


state 91

    (83) expList -> empty .

    RPAREN          reduce using rule 83 (expList -> empty .)
    SEMICOLON       reduce using rule 83 (expList -> empty .)


state 92

    (84) expSeq -> exp .
    (85) expSeq -> exp . COMMA expSeq
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 84 (expSeq -> exp .)
    RPAREN          reduce using rule 84 (expSeq -> exp .)
    COMMA           shift and go to state 131
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 93

    (82) expList -> expSeq .

    RPAREN          reduce using rule 82 (expList -> expSeq .)
    SEMICOLON       reduce using rule 82 (expList -> expSeq .)


state 94

    (63) var -> ID LCOR . exp RCOR
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 128
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 91

    (31) readStmt -> READ var . SEMICOLON

    SEMICOLON       shift and go to state 129


state 92

    (62) var -> ID .
    (63) var -> ID . LCOR exp RCOR

    SEMICOLON       reduce using rule 62 (var -> ID .)
    ASSIGN          reduce using rule 62 (var -> ID .)
    PLUSASSIGN      reduce using rule 62 (var -> ID .)
    MINUSASSIGN     reduce using rule 62 (var -> ID .)
    MULTASSIGN      reduce using rule 62 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 62 (var -> ID .)
    MODASSIGN       reduce using rule 62 (var -> ID .)
    LCOR            shift and go to state 104


state 93

    (36) assign -> var ASSIGN . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 132
    var                            shift and go to state 84

state 95

    (35) subCall -> ID LPAREN . expList RPAREN
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

<<<<<<< HEAD
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 130
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 94

    (37) assign -> var PLUSASSIGN . exp
=======
    RPAREN          reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 86
    expList                        shift and go to state 133
    empty                          shift and go to state 91
    exp                            shift and go to state 92
    subCall                        shift and go to state 81
    expSeq                         shift and go to state 93
    var                            shift and go to state 84

state 96

    (23) stmt -> assign SEMICOLON .

    error           reduce using rule 23 (stmt -> assign SEMICOLON .)
    IF              reduce using rule 23 (stmt -> assign SEMICOLON .)
    WHILE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    FOR             reduce using rule 23 (stmt -> assign SEMICOLON .)
    BREAK           reduce using rule 23 (stmt -> assign SEMICOLON .)
    RETURN          reduce using rule 23 (stmt -> assign SEMICOLON .)
    READ            reduce using rule 23 (stmt -> assign SEMICOLON .)
    WRITE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    ID              reduce using rule 23 (stmt -> assign SEMICOLON .)
    RKEY            reduce using rule 23 (stmt -> assign SEMICOLON .)


state 97

    (78) stmtList -> stmt stmtList .

    RKEY            reduce using rule 78 (stmtList -> stmt stmtList .)


state 98

    (38) assign -> var MINUSASSIGN . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 131
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 95

    (38) assign -> var MINUSASSIGN . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 134
    var                            shift and go to state 84

state 99

    (36) assign -> var ASSIGN . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 132
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 96

    (39) assign -> var MULTASSIGN . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 135
    var                            shift and go to state 84

state 100

    (41) assign -> var MODASSIGN . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 133
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 97
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 136
    var                            shift and go to state 84

state 101
>>>>>>> master

    (40) assign -> var DIVIDEASSIGN . exp
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 134
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 98

    (41) assign -> var MODASSIGN . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 137
    var                            shift and go to state 84

state 102

    (39) assign -> var MULTASSIGN . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    var                            shift and go to state 88
    exp                            shift and go to state 135
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 99

    (32) writeStmt -> WRITE expList . SEMICOLON

    SEMICOLON       shift and go to state 136


state 100

    (82) expList -> expSeq .

    SEMICOLON       reduce using rule 82 (expList -> expSeq .)
    RPAREN          reduce using rule 82 (expList -> expSeq .)


state 101

    (83) expList -> empty .

    SEMICOLON       reduce using rule 83 (expList -> empty .)
    RPAREN          reduce using rule 83 (expList -> empty .)


state 102

    (84) expSeq -> exp .
    (85) expSeq -> exp . COMMA expSeq
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

    SEMICOLON       reduce using rule 84 (expSeq -> exp .)
    RPAREN          reduce using rule 84 (expSeq -> exp .)
    COMMA           shift and go to state 137
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 103

    (35) subCall -> ID LPAREN . expList RPAREN
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 138
    var                            shift and go to state 84

state 103

    (37) assign -> var PLUSASSIGN . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

<<<<<<< HEAD
    RPAREN          reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    expList                        shift and go to state 138
    expSeq                         shift and go to state 100
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 104

    (63) var -> ID LCOR . exp RCOR
=======
    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 139
    var                            shift and go to state 84

state 104

    (62) var -> ID .
    (63) var -> ID . LCOR exp RCOR

    ASSIGN          reduce using rule 62 (var -> ID .)
    PLUSASSIGN      reduce using rule 62 (var -> ID .)
    MINUSASSIGN     reduce using rule 62 (var -> ID .)
    MULTASSIGN      reduce using rule 62 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 62 (var -> ID .)
    MODASSIGN       reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)
    LCOR            shift and go to state 94


state 105

    (31) readStmt -> READ var . SEMICOLON

    SEMICOLON       shift and go to state 140


state 106

    (26) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY
    (27) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 139
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 105

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)


state 106

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq . RKEY

    RKEY            shift and go to state 140


state 107

    (80) literalSeq -> literal .
    (81) literalSeq -> literal . COMMA literalSeq

    RKEY            reduce using rule 80 (literalSeq -> literal .)
    COMMA           shift and go to state 141


state 108

    (26) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY
    (27) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY ELSE LKEY block RKEY
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 86
    exp                            shift and go to state 141
    subCall                        shift and go to state 81
    var                            shift and go to state 84

state 107

    (30) breakStmt -> BREAK SEMICOLON .

    error           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    IF              reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    READ            reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    WRITE           reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    ID              reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)
    RKEY            reduce using rule 30 (breakStmt -> BREAK SEMICOLON .)


state 108

    (81) literalSeq -> literal COMMA . literalSeq
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 76
    literalSeq                     shift and go to state 142

state 109

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .

    COMMA           reduce using rule 9 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)
    SEMICOLON       reduce using rule 9 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)


state 110

    (28) whileStmt -> WHILE LPAREN exp . RPAREN LKEY block RKEY
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    RPAREN          shift and go to state 142
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 109

    (28) whileStmt -> WHILE LPAREN exp . RPAREN LKEY block RKEY
=======
    RPAREN          shift and go to state 143
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 111

    (29) forStmt -> FOR LPAREN assign . SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    SEMICOLON       shift and go to state 144


state 112

    (61) exp -> LPAREN exp . RPAREN
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    RPAREN          shift and go to state 143
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 110

    (29) forStmt -> FOR LPAREN assign . SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    SEMICOLON       shift and go to state 144


state 111

    (34) returnStmt -> RETURN exp SEMICOLON .

    error           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    IF              reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    READ            reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    WRITE           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    RKEY            reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)


state 112

    (42) exp -> exp PLUS . exp
=======
    RPAREN          shift and go to state 145
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 113

    (56) exp -> UMINUS exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    COMMA           reduce using rule 56 (exp -> UMINUS exp .)
    RPAREN          reduce using rule 56 (exp -> UMINUS exp .)
    SEMICOLON       reduce using rule 56 (exp -> UMINUS exp .)
    RCOR            reduce using rule 56 (exp -> UMINUS exp .)
    COLON           reduce using rule 56 (exp -> UMINUS exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! MULT            [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! EQUALS          [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! GT              [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! GTE             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! LT              [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! LTE             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! AND             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! OR              [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! QMARK           [ reduce using rule 56 (exp -> UMINUS exp .) ]


state 114

    (55) exp -> NOT exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    COMMA           reduce using rule 55 (exp -> NOT exp .)
    RPAREN          reduce using rule 55 (exp -> NOT exp .)
    SEMICOLON       reduce using rule 55 (exp -> NOT exp .)
    RCOR            reduce using rule 55 (exp -> NOT exp .)
    COLON           reduce using rule 55 (exp -> NOT exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 55 (exp -> NOT exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> NOT exp .) ]
  ! MULT            [ reduce using rule 55 (exp -> NOT exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! EQUALS          [ reduce using rule 55 (exp -> NOT exp .) ]
  ! DIFFERENT       [ reduce using rule 55 (exp -> NOT exp .) ]
  ! GT              [ reduce using rule 55 (exp -> NOT exp .) ]
  ! GTE             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! LT              [ reduce using rule 55 (exp -> NOT exp .) ]
  ! LTE             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! AND             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! OR              [ reduce using rule 55 (exp -> NOT exp .) ]
  ! QMARK           [ reduce using rule 55 (exp -> NOT exp .) ]


state 115

    (44) exp -> exp MULT . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 145
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 113

    (43) exp -> exp MINUS . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 146
    var                            shift and go to state 84

state 116

    (51) exp -> exp LT . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 146
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 114

    (44) exp -> exp MULT . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 147
    var                            shift and go to state 84

state 117

    (45) exp -> exp DIVIDE . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 147
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 115

    (45) exp -> exp DIVIDE . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 148
    var                            shift and go to state 84

state 118

    (49) exp -> exp GT . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 148
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 116

    (46) exp -> exp MOD . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 149
    var                            shift and go to state 84

state 119

    (57) exp -> exp QMARK . exp COLON exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 149
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 117

    (47) exp -> exp EQUALS . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 150
    var                            shift and go to state 84

state 120

    (34) returnStmt -> RETURN exp SEMICOLON .

    error           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    IF              reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    READ            reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    WRITE           reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)
    RKEY            reduce using rule 34 (returnStmt -> RETURN exp SEMICOLON .)


state 121

    (52) exp -> exp LTE . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 150
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 118

    (48) exp -> exp DIFFERENT . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 151
    var                            shift and go to state 84

state 122

    (43) exp -> exp MINUS . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 151
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 119

    (49) exp -> exp GT . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 152
    var                            shift and go to state 84

state 123

    (42) exp -> exp PLUS . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 152
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 120
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 153
    var                            shift and go to state 84

state 124
>>>>>>> master

    (50) exp -> exp GTE . exp
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 153
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 121

    (51) exp -> exp LT . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 154
    var                            shift and go to state 84

state 125

    (54) exp -> exp OR . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 154
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 122

    (52) exp -> exp LTE . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 155
    var                            shift and go to state 84

state 126

    (48) exp -> exp DIFFERENT . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 155
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 123

    (53) exp -> exp AND . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 156
    var                            shift and go to state 84

state 127

    (46) exp -> exp MOD . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 156
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 124

    (54) exp -> exp OR . exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 157
    var                            shift and go to state 84

state 128

    (53) exp -> exp AND . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 157
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 125

    (57) exp -> exp QMARK . exp COLON exp
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 158
    var                            shift and go to state 84

state 129

    (47) exp -> exp EQUALS . exp
>>>>>>> master
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 158
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 126

    (55) exp -> NOT exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 55 (exp -> NOT exp .)
    COMMA           reduce using rule 55 (exp -> NOT exp .)
    RPAREN          reduce using rule 55 (exp -> NOT exp .)
    RCOR            reduce using rule 55 (exp -> NOT exp .)
    COLON           reduce using rule 55 (exp -> NOT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 55 (exp -> NOT exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> NOT exp .) ]
  ! MULT            [ reduce using rule 55 (exp -> NOT exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! EQUALS          [ reduce using rule 55 (exp -> NOT exp .) ]
  ! DIFFERENT       [ reduce using rule 55 (exp -> NOT exp .) ]
  ! GT              [ reduce using rule 55 (exp -> NOT exp .) ]
  ! GTE             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! LT              [ reduce using rule 55 (exp -> NOT exp .) ]
  ! LTE             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! AND             [ reduce using rule 55 (exp -> NOT exp .) ]
  ! OR              [ reduce using rule 55 (exp -> NOT exp .) ]
  ! QMARK           [ reduce using rule 55 (exp -> NOT exp .) ]


state 127

    (56) exp -> UMINUS exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 56 (exp -> UMINUS exp .)
    COMMA           reduce using rule 56 (exp -> UMINUS exp .)
    RPAREN          reduce using rule 56 (exp -> UMINUS exp .)
    RCOR            reduce using rule 56 (exp -> UMINUS exp .)
    COLON           reduce using rule 56 (exp -> UMINUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! MULT            [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! EQUALS          [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! GT              [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! GTE             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! LT              [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! LTE             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! AND             [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! OR              [ reduce using rule 56 (exp -> UMINUS exp .) ]
  ! QMARK           [ reduce using rule 56 (exp -> UMINUS exp .) ]


state 128

    (61) exp -> LPAREN exp . RPAREN
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 159
    var                            shift and go to state 84

state 130

    (32) writeStmt -> WRITE expList SEMICOLON .

    error           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    IF              reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    WHILE           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    FOR             reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    BREAK           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    RETURN          reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    READ            reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    WRITE           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    ID              reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    RKEY            reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)


state 131

    (85) expSeq -> exp COMMA . expSeq
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 86
    exp                            shift and go to state 92
    subCall                        shift and go to state 81
    expSeq                         shift and go to state 160
    var                            shift and go to state 84

state 132

    (63) var -> ID LCOR exp . RCOR
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    RPAREN          shift and go to state 159
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 129

    (31) readStmt -> READ var SEMICOLON .

    error           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    IF              reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    WHILE           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    FOR             reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    BREAK           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    RETURN          reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    READ            reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    WRITE           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    ID              reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    RKEY            reduce using rule 31 (readStmt -> READ var SEMICOLON .)


state 130

    (36) assign -> var ASSIGN exp .
=======
    RCOR            shift and go to state 161
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 133

    (35) subCall -> ID LPAREN expList . RPAREN

    RPAREN          shift and go to state 162


state 134

    (38) assign -> var MINUSASSIGN exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       reduce using rule 36 (assign -> var ASSIGN exp .)
    RPAREN          reduce using rule 36 (assign -> var ASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 131

    (37) assign -> var PLUSASSIGN exp .
=======
    RPAREN          reduce using rule 38 (assign -> var MINUSASSIGN exp .)
    SEMICOLON       reduce using rule 38 (assign -> var MINUSASSIGN exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 135

    (36) assign -> var ASSIGN exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       reduce using rule 37 (assign -> var PLUSASSIGN exp .)
    RPAREN          reduce using rule 37 (assign -> var PLUSASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 132

    (38) assign -> var MINUSASSIGN exp .
=======
    RPAREN          reduce using rule 36 (assign -> var ASSIGN exp .)
    SEMICOLON       reduce using rule 36 (assign -> var ASSIGN exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 136

    (41) assign -> var MODASSIGN exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       reduce using rule 38 (assign -> var MINUSASSIGN exp .)
    RPAREN          reduce using rule 38 (assign -> var MINUSASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 133

    (39) assign -> var MULTASSIGN exp .
=======
    RPAREN          reduce using rule 41 (assign -> var MODASSIGN exp .)
    SEMICOLON       reduce using rule 41 (assign -> var MODASSIGN exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 137

    (40) assign -> var DIVIDEASSIGN exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       reduce using rule 39 (assign -> var MULTASSIGN exp .)
    RPAREN          reduce using rule 39 (assign -> var MULTASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 134

    (40) assign -> var DIVIDEASSIGN exp .
=======
    RPAREN          reduce using rule 40 (assign -> var DIVIDEASSIGN exp .)
    SEMICOLON       reduce using rule 40 (assign -> var DIVIDEASSIGN exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 138

    (39) assign -> var MULTASSIGN exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       reduce using rule 40 (assign -> var DIVIDEASSIGN exp .)
    RPAREN          reduce using rule 40 (assign -> var DIVIDEASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 135

    (41) assign -> var MODASSIGN exp .
=======
    RPAREN          reduce using rule 39 (assign -> var MULTASSIGN exp .)
    SEMICOLON       reduce using rule 39 (assign -> var MULTASSIGN exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 139

    (37) assign -> var PLUSASSIGN exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       reduce using rule 41 (assign -> var MODASSIGN exp .)
    RPAREN          reduce using rule 41 (assign -> var MODASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 136

    (32) writeStmt -> WRITE expList SEMICOLON .

    error           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    IF              reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    WHILE           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    FOR             reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    BREAK           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    RETURN          reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    READ            reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    WRITE           reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    ID              reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)
    RKEY            reduce using rule 32 (writeStmt -> WRITE expList SEMICOLON .)


state 137

    (85) expSeq -> exp COMMA . expSeq
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 102
    expSeq                         shift and go to state 160
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 138

    (35) subCall -> ID LPAREN expList . RPAREN

    RPAREN          shift and go to state 161


state 139

    (63) var -> ID LCOR exp . RCOR
=======
    RPAREN          reduce using rule 37 (assign -> var PLUSASSIGN exp .)
    SEMICOLON       reduce using rule 37 (assign -> var PLUSASSIGN exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 140

    (31) readStmt -> READ var SEMICOLON .

    error           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    IF              reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    WHILE           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    FOR             reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    BREAK           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    RETURN          reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    READ            reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    WRITE           reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    ID              reduce using rule 31 (readStmt -> READ var SEMICOLON .)
    RKEY            reduce using rule 31 (readStmt -> READ var SEMICOLON .)


state 141

    (26) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY
    (27) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY ELSE LKEY block RKEY
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    RCOR            shift and go to state 162
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 140

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .

    COMMA           reduce using rule 9 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)
    SEMICOLON       reduce using rule 9 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)


state 141

    (81) literalSeq -> literal COMMA . literalSeq
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    literal                        shift and go to state 107
    literalSeq                     shift and go to state 163

state 142

    (26) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY
    (27) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY ELSE LKEY block RKEY

    LKEY            shift and go to state 164
=======
    RPAREN          shift and go to state 163
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 142

    (81) literalSeq -> literal COMMA literalSeq .

    RKEY            reduce using rule 81 (literalSeq -> literal COMMA literalSeq .)
>>>>>>> master


state 143

    (28) whileStmt -> WHILE LPAREN exp RPAREN . LKEY block RKEY

<<<<<<< HEAD
    LKEY            shift and go to state 165
=======
    LKEY            shift and go to state 164
>>>>>>> master


state 144

    (29) forStmt -> FOR LPAREN assign SEMICOLON . exp SEMICOLON assign RPAREN LKEY block RKEY
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
<<<<<<< HEAD
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 166
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 145

    (42) exp -> exp PLUS exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 42 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 42 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 42 (exp -> exp PLUS exp .)
    RCOR            reduce using rule 42 (exp -> exp PLUS exp .)
    COLON           reduce using rule 42 (exp -> exp PLUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! MULT            [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! EQUALS          [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! DIFFERENT       [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! GT              [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! GTE             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! LT              [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! LTE             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! AND             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! OR              [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! QMARK           [ reduce using rule 42 (exp -> exp PLUS exp .) ]
=======
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    literal                        shift and go to state 86
    exp                            shift and go to state 165
    subCall                        shift and go to state 81
    var                            shift and go to state 84

state 145

    (61) exp -> LPAREN exp RPAREN .

    COMMA           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    MULT            reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    DIFFERENT       reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    QMARK           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    RCOR            reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    COLON           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
>>>>>>> master


state 146

<<<<<<< HEAD
    (43) exp -> exp MINUS exp .
=======
    (44) exp -> exp MULT exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 43 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 43 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 43 (exp -> exp MINUS exp .)
    RCOR            reduce using rule 43 (exp -> exp MINUS exp .)
    COLON           reduce using rule 43 (exp -> exp MINUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! MINUS           [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! MULT            [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! EQUALS          [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! GT              [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! GTE             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! LT              [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! LTE             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! AND             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! OR              [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! QMARK           [ reduce using rule 43 (exp -> exp MINUS exp .) ]
=======
    COMMA           reduce using rule 44 (exp -> exp MULT exp .)
    RPAREN          reduce using rule 44 (exp -> exp MULT exp .)
    SEMICOLON       reduce using rule 44 (exp -> exp MULT exp .)
    RCOR            reduce using rule 44 (exp -> exp MULT exp .)
    COLON           reduce using rule 44 (exp -> exp MULT exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! MULT            [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! EQUALS          [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! DIFFERENT       [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! GT              [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! GTE             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! LT              [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! LTE             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! AND             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! OR              [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! QMARK           [ reduce using rule 44 (exp -> exp MULT exp .) ]
>>>>>>> master


state 147

<<<<<<< HEAD
    (44) exp -> exp MULT exp .
=======
    (51) exp -> exp LT exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 44 (exp -> exp MULT exp .)
    COMMA           reduce using rule 44 (exp -> exp MULT exp .)
    RPAREN          reduce using rule 44 (exp -> exp MULT exp .)
    RCOR            reduce using rule 44 (exp -> exp MULT exp .)
    COLON           reduce using rule 44 (exp -> exp MULT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! MULT            [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! EQUALS          [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! DIFFERENT       [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! GT              [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! GTE             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! LT              [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! LTE             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! AND             [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! OR              [ reduce using rule 44 (exp -> exp MULT exp .) ]
  ! QMARK           [ reduce using rule 44 (exp -> exp MULT exp .) ]
=======
    COMMA           reduce using rule 51 (exp -> exp LT exp .)
    RPAREN          reduce using rule 51 (exp -> exp LT exp .)
    SEMICOLON       reduce using rule 51 (exp -> exp LT exp .)
    RCOR            reduce using rule 51 (exp -> exp LT exp .)
    COLON           reduce using rule 51 (exp -> exp LT exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MULT            [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MOD             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! EQUALS          [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! DIFFERENT       [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! GT              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! GTE             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! LT              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! LTE             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! AND             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! OR              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! QMARK           [ reduce using rule 51 (exp -> exp LT exp .) ]
>>>>>>> master


state 148

    (45) exp -> exp DIVIDE exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 45 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 45 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 45 (exp -> exp DIVIDE exp .)
    RCOR            reduce using rule 45 (exp -> exp DIVIDE exp .)
    COLON           reduce using rule 45 (exp -> exp DIVIDE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125
=======
    COMMA           reduce using rule 45 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 45 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 45 (exp -> exp DIVIDE exp .)
    RCOR            reduce using rule 45 (exp -> exp DIVIDE exp .)
    COLON           reduce using rule 45 (exp -> exp DIVIDE exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119
>>>>>>> master

  ! PLUS            [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! MINUS           [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! MULT            [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! EQUALS          [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! DIFFERENT       [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! GT              [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! GTE             [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! LT              [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! LTE             [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! AND             [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! OR              [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]
  ! QMARK           [ reduce using rule 45 (exp -> exp DIVIDE exp .) ]


state 149

<<<<<<< HEAD
    (46) exp -> exp MOD exp .
=======
    (49) exp -> exp GT exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 46 (exp -> exp MOD exp .)
    COMMA           reduce using rule 46 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 46 (exp -> exp MOD exp .)
    RCOR            reduce using rule 46 (exp -> exp MOD exp .)
    COLON           reduce using rule 46 (exp -> exp MOD exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! MULT            [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! EQUALS          [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! DIFFERENT       [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! GT              [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! GTE             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! LT              [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! LTE             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! AND             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! OR              [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! QMARK           [ reduce using rule 46 (exp -> exp MOD exp .) ]
=======
    COMMA           reduce using rule 49 (exp -> exp GT exp .)
    RPAREN          reduce using rule 49 (exp -> exp GT exp .)
    SEMICOLON       reduce using rule 49 (exp -> exp GT exp .)
    RCOR            reduce using rule 49 (exp -> exp GT exp .)
    COLON           reduce using rule 49 (exp -> exp GT exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! MULT            [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! MOD             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! EQUALS          [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! DIFFERENT       [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! GT              [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! GTE             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! LT              [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! LTE             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! AND             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! OR              [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! QMARK           [ reduce using rule 49 (exp -> exp GT exp .) ]
>>>>>>> master


state 150

<<<<<<< HEAD
    (47) exp -> exp EQUALS exp .
=======
    (57) exp -> exp QMARK exp . COLON exp
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

    COLON           shift and go to state 166
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 151

    (52) exp -> exp LTE exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 47 (exp -> exp EQUALS exp .)
    COMMA           reduce using rule 47 (exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 47 (exp -> exp EQUALS exp .)
    RCOR            reduce using rule 47 (exp -> exp EQUALS exp .)
    COLON           reduce using rule 47 (exp -> exp EQUALS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! MULT            [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! EQUALS          [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! DIFFERENT       [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! GT              [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! GTE             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! LT              [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! LTE             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! AND             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! OR              [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! QMARK           [ reduce using rule 47 (exp -> exp EQUALS exp .) ]


state 151

    (48) exp -> exp DIFFERENT exp .
=======
    COMMA           reduce using rule 52 (exp -> exp LTE exp .)
    RPAREN          reduce using rule 52 (exp -> exp LTE exp .)
    SEMICOLON       reduce using rule 52 (exp -> exp LTE exp .)
    RCOR            reduce using rule 52 (exp -> exp LTE exp .)
    COLON           reduce using rule 52 (exp -> exp LTE exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! MULT            [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! MOD             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! EQUALS          [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! DIFFERENT       [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! GT              [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! GTE             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! LT              [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! LTE             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! AND             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! OR              [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! QMARK           [ reduce using rule 52 (exp -> exp LTE exp .) ]


state 152

    (43) exp -> exp MINUS exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
<<<<<<< HEAD
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    SEMICOLON       reduce using rule 48 (exp -> exp DIFFERENT exp .)
    COMMA           reduce using rule 48 (exp -> exp DIFFERENT exp .)
    RPAREN          reduce using rule 48 (exp -> exp DIFFERENT exp .)
    RCOR            reduce using rule 48 (exp -> exp DIFFERENT exp .)
    COLON           reduce using rule 48 (exp -> exp DIFFERENT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! MULT            [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! EQUALS          [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! DIFFERENT       [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! GT              [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! GTE             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! LT              [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! LTE             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! AND             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! OR              [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! QMARK           [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]


state 152

    (49) exp -> exp GT exp .
=======
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    COMMA           reduce using rule 43 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 43 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 43 (exp -> exp MINUS exp .)
    RCOR            reduce using rule 43 (exp -> exp MINUS exp .)
    COLON           reduce using rule 43 (exp -> exp MINUS exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! MINUS           [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! MULT            [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! EQUALS          [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! GT              [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! GTE             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! LT              [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! LTE             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! AND             [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! OR              [ reduce using rule 43 (exp -> exp MINUS exp .) ]
  ! QMARK           [ reduce using rule 43 (exp -> exp MINUS exp .) ]


state 153

    (42) exp -> exp PLUS exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 49 (exp -> exp GT exp .)
    COMMA           reduce using rule 49 (exp -> exp GT exp .)
    RPAREN          reduce using rule 49 (exp -> exp GT exp .)
    RCOR            reduce using rule 49 (exp -> exp GT exp .)
    COLON           reduce using rule 49 (exp -> exp GT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! MULT            [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! MOD             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! EQUALS          [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! DIFFERENT       [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! GT              [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! GTE             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! LT              [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! LTE             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! AND             [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! OR              [ reduce using rule 49 (exp -> exp GT exp .) ]
  ! QMARK           [ reduce using rule 49 (exp -> exp GT exp .) ]


state 153
=======
    COMMA           reduce using rule 42 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 42 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 42 (exp -> exp PLUS exp .)
    RCOR            reduce using rule 42 (exp -> exp PLUS exp .)
    COLON           reduce using rule 42 (exp -> exp PLUS exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! MULT            [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! EQUALS          [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! DIFFERENT       [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! GT              [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! GTE             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! LT              [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! LTE             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! AND             [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! OR              [ reduce using rule 42 (exp -> exp PLUS exp .) ]
  ! QMARK           [ reduce using rule 42 (exp -> exp PLUS exp .) ]


state 154
>>>>>>> master

    (50) exp -> exp GTE exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 50 (exp -> exp GTE exp .)
    COMMA           reduce using rule 50 (exp -> exp GTE exp .)
    RPAREN          reduce using rule 50 (exp -> exp GTE exp .)
    RCOR            reduce using rule 50 (exp -> exp GTE exp .)
    COLON           reduce using rule 50 (exp -> exp GTE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125
=======
    COMMA           reduce using rule 50 (exp -> exp GTE exp .)
    RPAREN          reduce using rule 50 (exp -> exp GTE exp .)
    SEMICOLON       reduce using rule 50 (exp -> exp GTE exp .)
    RCOR            reduce using rule 50 (exp -> exp GTE exp .)
    COLON           reduce using rule 50 (exp -> exp GTE exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119
>>>>>>> master

  ! PLUS            [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! MINUS           [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! MULT            [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! DIVIDE          [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! MOD             [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! EQUALS          [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! DIFFERENT       [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! GT              [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! GTE             [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! LT              [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! LTE             [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! AND             [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! OR              [ reduce using rule 50 (exp -> exp GTE exp .) ]
  ! QMARK           [ reduce using rule 50 (exp -> exp GTE exp .) ]


<<<<<<< HEAD
state 154

    (51) exp -> exp LT exp .
=======
state 155

    (54) exp -> exp OR exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 51 (exp -> exp LT exp .)
    COMMA           reduce using rule 51 (exp -> exp LT exp .)
    RPAREN          reduce using rule 51 (exp -> exp LT exp .)
    RCOR            reduce using rule 51 (exp -> exp LT exp .)
    COLON           reduce using rule 51 (exp -> exp LT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MULT            [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MOD             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! EQUALS          [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! DIFFERENT       [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! GT              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! GTE             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! LT              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! LTE             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! AND             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! OR              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! QMARK           [ reduce using rule 51 (exp -> exp LT exp .) ]


state 155

    (52) exp -> exp LTE exp .
=======
    COMMA           reduce using rule 54 (exp -> exp OR exp .)
    RPAREN          reduce using rule 54 (exp -> exp OR exp .)
    SEMICOLON       reduce using rule 54 (exp -> exp OR exp .)
    RCOR            reduce using rule 54 (exp -> exp OR exp .)
    COLON           reduce using rule 54 (exp -> exp OR exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! MULT            [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! GTE             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! LTE             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! OR              [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! QMARK           [ reduce using rule 54 (exp -> exp OR exp .) ]


state 156

    (48) exp -> exp DIFFERENT exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 52 (exp -> exp LTE exp .)
    COMMA           reduce using rule 52 (exp -> exp LTE exp .)
    RPAREN          reduce using rule 52 (exp -> exp LTE exp .)
    RCOR            reduce using rule 52 (exp -> exp LTE exp .)
    COLON           reduce using rule 52 (exp -> exp LTE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! MULT            [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! MOD             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! EQUALS          [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! DIFFERENT       [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! GT              [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! GTE             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! LT              [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! LTE             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! AND             [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! OR              [ reduce using rule 52 (exp -> exp LTE exp .) ]
  ! QMARK           [ reduce using rule 52 (exp -> exp LTE exp .) ]


state 156

    (53) exp -> exp AND exp .
=======
    COMMA           reduce using rule 48 (exp -> exp DIFFERENT exp .)
    RPAREN          reduce using rule 48 (exp -> exp DIFFERENT exp .)
    SEMICOLON       reduce using rule 48 (exp -> exp DIFFERENT exp .)
    RCOR            reduce using rule 48 (exp -> exp DIFFERENT exp .)
    COLON           reduce using rule 48 (exp -> exp DIFFERENT exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! MULT            [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! EQUALS          [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! DIFFERENT       [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! GT              [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! GTE             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! LT              [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! LTE             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! AND             [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! OR              [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]
  ! QMARK           [ reduce using rule 48 (exp -> exp DIFFERENT exp .) ]


state 157

    (46) exp -> exp MOD exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 53 (exp -> exp AND exp .)
    COMMA           reduce using rule 53 (exp -> exp AND exp .)
    RPAREN          reduce using rule 53 (exp -> exp AND exp .)
    RCOR            reduce using rule 53 (exp -> exp AND exp .)
    COLON           reduce using rule 53 (exp -> exp AND exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! MULT            [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! GTE             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! LTE             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! AND             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! OR              [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! QMARK           [ reduce using rule 53 (exp -> exp AND exp .) ]


state 157

    (54) exp -> exp OR exp .
=======
    COMMA           reduce using rule 46 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 46 (exp -> exp MOD exp .)
    SEMICOLON       reduce using rule 46 (exp -> exp MOD exp .)
    RCOR            reduce using rule 46 (exp -> exp MOD exp .)
    COLON           reduce using rule 46 (exp -> exp MOD exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! MULT            [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! EQUALS          [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! DIFFERENT       [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! GT              [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! GTE             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! LT              [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! LTE             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! AND             [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! OR              [ reduce using rule 46 (exp -> exp MOD exp .) ]
  ! QMARK           [ reduce using rule 46 (exp -> exp MOD exp .) ]


state 158

    (53) exp -> exp AND exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 54 (exp -> exp OR exp .)
    COMMA           reduce using rule 54 (exp -> exp OR exp .)
    RPAREN          reduce using rule 54 (exp -> exp OR exp .)
    RCOR            reduce using rule 54 (exp -> exp OR exp .)
    COLON           reduce using rule 54 (exp -> exp OR exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125

  ! PLUS            [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! MULT            [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! GTE             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! LTE             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! OR              [ reduce using rule 54 (exp -> exp OR exp .) ]
  ! QMARK           [ reduce using rule 54 (exp -> exp OR exp .) ]


state 158

    (57) exp -> exp QMARK exp . COLON exp
=======
    COMMA           reduce using rule 53 (exp -> exp AND exp .)
    RPAREN          reduce using rule 53 (exp -> exp AND exp .)
    SEMICOLON       reduce using rule 53 (exp -> exp AND exp .)
    RCOR            reduce using rule 53 (exp -> exp AND exp .)
    COLON           reduce using rule 53 (exp -> exp AND exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! MULT            [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! GTE             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! LTE             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! AND             [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! OR              [ reduce using rule 53 (exp -> exp AND exp .) ]
  ! QMARK           [ reduce using rule 53 (exp -> exp AND exp .) ]


state 159

    (47) exp -> exp EQUALS exp .
>>>>>>> master
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    COLON           shift and go to state 167
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 159

    (61) exp -> LPAREN exp RPAREN .

    SEMICOLON       reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    MULT            reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    DIFFERENT       reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    QMARK           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    RCOR            reduce using rule 61 (exp -> LPAREN exp RPAREN .)
    COLON           reduce using rule 61 (exp -> LPAREN exp RPAREN .)
=======
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
    COMMA           reduce using rule 47 (exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 47 (exp -> exp EQUALS exp .)
    SEMICOLON       reduce using rule 47 (exp -> exp EQUALS exp .)
    RCOR            reduce using rule 47 (exp -> exp EQUALS exp .)
    COLON           reduce using rule 47 (exp -> exp EQUALS exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119

  ! PLUS            [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! MULT            [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! EQUALS          [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! DIFFERENT       [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! GT              [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! GTE             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! LT              [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! LTE             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! AND             [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! OR              [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
  ! QMARK           [ reduce using rule 47 (exp -> exp EQUALS exp .) ]
>>>>>>> master


state 160

    (85) expSeq -> exp COMMA expSeq .

    SEMICOLON       reduce using rule 85 (expSeq -> exp COMMA expSeq .)
    RPAREN          reduce using rule 85 (expSeq -> exp COMMA expSeq .)


state 161

<<<<<<< HEAD
    (35) subCall -> ID LPAREN expList RPAREN .

    SEMICOLON       reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    PLUS            reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    MINUS           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    MULT            reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    DIVIDE          reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    MOD             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    EQUALS          reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    DIFFERENT       reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    GT              reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    GTE             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    LT              reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    LTE             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    AND             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    OR              reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    QMARK           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    COMMA           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    RPAREN          reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    RCOR            reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    COLON           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)


state 162

    (63) var -> ID LCOR exp RCOR .

    ASSIGN          reduce using rule 63 (var -> ID LCOR exp RCOR .)
    PLUSASSIGN      reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MINUSASSIGN     reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MULTASSIGN      reduce using rule 63 (var -> ID LCOR exp RCOR .)
    DIVIDEASSIGN    reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MODASSIGN       reduce using rule 63 (var -> ID LCOR exp RCOR .)
    SEMICOLON       reduce using rule 63 (var -> ID LCOR exp RCOR .)
=======
    (63) var -> ID LCOR exp RCOR .

>>>>>>> master
    PLUS            reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MINUS           reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MULT            reduce using rule 63 (var -> ID LCOR exp RCOR .)
    DIVIDE          reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MOD             reduce using rule 63 (var -> ID LCOR exp RCOR .)
    EQUALS          reduce using rule 63 (var -> ID LCOR exp RCOR .)
    DIFFERENT       reduce using rule 63 (var -> ID LCOR exp RCOR .)
    GT              reduce using rule 63 (var -> ID LCOR exp RCOR .)
    GTE             reduce using rule 63 (var -> ID LCOR exp RCOR .)
    LT              reduce using rule 63 (var -> ID LCOR exp RCOR .)
    LTE             reduce using rule 63 (var -> ID LCOR exp RCOR .)
    AND             reduce using rule 63 (var -> ID LCOR exp RCOR .)
    OR              reduce using rule 63 (var -> ID LCOR exp RCOR .)
    QMARK           reduce using rule 63 (var -> ID LCOR exp RCOR .)
<<<<<<< HEAD
=======
    SEMICOLON       reduce using rule 63 (var -> ID LCOR exp RCOR .)
>>>>>>> master
    COMMA           reduce using rule 63 (var -> ID LCOR exp RCOR .)
    RPAREN          reduce using rule 63 (var -> ID LCOR exp RCOR .)
    RCOR            reduce using rule 63 (var -> ID LCOR exp RCOR .)
    COLON           reduce using rule 63 (var -> ID LCOR exp RCOR .)
<<<<<<< HEAD


state 163

    (81) literalSeq -> literal COMMA literalSeq .

    RKEY            reduce using rule 81 (literalSeq -> literal COMMA literalSeq .)


state 164

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY ELSE LKEY block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 168
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 165
=======
    ASSIGN          reduce using rule 63 (var -> ID LCOR exp RCOR .)
    PLUSASSIGN      reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MINUSASSIGN     reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MULTASSIGN      reduce using rule 63 (var -> ID LCOR exp RCOR .)
    DIVIDEASSIGN    reduce using rule 63 (var -> ID LCOR exp RCOR .)
    MODASSIGN       reduce using rule 63 (var -> ID LCOR exp RCOR .)


state 162

    (35) subCall -> ID LPAREN expList RPAREN .

    RPAREN          reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    PLUS            reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    MINUS           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    MULT            reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    DIVIDE          reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    MOD             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    EQUALS          reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    DIFFERENT       reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    GT              reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    GTE             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    LT              reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    LTE             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    AND             reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    OR              reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    QMARK           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    SEMICOLON       reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    COMMA           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    RCOR            reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)
    COLON           reduce using rule 35 (subCall -> ID LPAREN expList RPAREN .)


state 163

    (26) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY
    (27) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY ELSE LKEY block RKEY

    LKEY            shift and go to state 167


state 164
>>>>>>> master

    (28) whileStmt -> WHILE LPAREN exp RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
<<<<<<< HEAD
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 169
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 166
=======
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    empty                          shift and go to state 49
    block                          shift and go to state 168
    varDec                         shift and go to state 46
    type                           shift and go to state 47
    varDecList                     shift and go to state 48

state 165
>>>>>>> master

    (29) forStmt -> FOR LPAREN assign SEMICOLON exp . SEMICOLON assign RPAREN LKEY block RKEY
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

<<<<<<< HEAD
    SEMICOLON       shift and go to state 170
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125


state 167
=======
    SEMICOLON       shift and go to state 169
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119


state 166
>>>>>>> master

    (57) exp -> exp QMARK exp COLON . exp
    (42) exp -> . exp PLUS exp
    (43) exp -> . exp MINUS exp
    (44) exp -> . exp MULT exp
    (45) exp -> . exp DIVIDE exp
    (46) exp -> . exp MOD exp
    (47) exp -> . exp EQUALS exp
    (48) exp -> . exp DIFFERENT exp
    (49) exp -> . exp GT exp
    (50) exp -> . exp GTE exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp LTE exp
    (53) exp -> . exp AND exp
    (54) exp -> . exp OR exp
    (55) exp -> . NOT exp
    (56) exp -> . UMINUS exp
    (57) exp -> . exp QMARK exp COLON exp
    (58) exp -> . subCall
    (59) exp -> . var
    (60) exp -> . literal
    (61) exp -> . LPAREN exp RPAREN
    (35) subCall -> . ID LPAREN expList RPAREN
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR
    (64) literal -> . NUMBER
    (65) literal -> . STRING_LITERAL
    (66) literal -> . FALSE
    (67) literal -> . TRUE

    NOT             shift and go to state 85
<<<<<<< HEAD
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 30
    STRING_LITERAL  shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33

    exp                            shift and go to state 171
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 168

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY ELSE LKEY block RKEY

    RKEY            shift and go to state 172


state 169

    (28) whileStmt -> WHILE LPAREN exp RPAREN LKEY block . RKEY

    RKEY            shift and go to state 173


state 170
=======
    UMINUS          shift and go to state 83
    LPAREN          shift and go to state 82
    ID              shift and go to state 62
    NUMBER          shift and go to state 32
    STRING_LITERAL  shift and go to state 29
    FALSE           shift and go to state 31
    TRUE            shift and go to state 30

    subCall                        shift and go to state 81
    literal                        shift and go to state 86
    exp                            shift and go to state 170
    var                            shift and go to state 84

state 167

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY ELSE LKEY block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    empty                          shift and go to state 49
    block                          shift and go to state 171
    varDec                         shift and go to state 46
    type                           shift and go to state 47
    varDecList                     shift and go to state 48

state 168

    (28) whileStmt -> WHILE LPAREN exp RPAREN LKEY block . RKEY

    RKEY            shift and go to state 172


state 169
>>>>>>> master

    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON . assign RPAREN LKEY block RKEY
    (36) assign -> . var ASSIGN exp
    (37) assign -> . var PLUSASSIGN exp
    (38) assign -> . var MINUSASSIGN exp
    (39) assign -> . var MULTASSIGN exp
    (40) assign -> . var DIVIDEASSIGN exp
    (41) assign -> . var MODASSIGN exp
    (62) var -> . ID
    (63) var -> . ID LCOR exp RCOR

<<<<<<< HEAD
    ID              shift and go to state 92

    assign                         shift and go to state 174
    var                            shift and go to state 70

state 171
=======
    ID              shift and go to state 104

    assign                         shift and go to state 173
    var                            shift and go to state 69

state 170
>>>>>>> master

    (57) exp -> exp QMARK exp COLON exp .
    (42) exp -> exp . PLUS exp
    (43) exp -> exp . MINUS exp
    (44) exp -> exp . MULT exp
    (45) exp -> exp . DIVIDE exp
    (46) exp -> exp . MOD exp
    (47) exp -> exp . EQUALS exp
    (48) exp -> exp . DIFFERENT exp
    (49) exp -> exp . GT exp
    (50) exp -> exp . GTE exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . LTE exp
    (53) exp -> exp . AND exp
    (54) exp -> exp . OR exp
    (57) exp -> exp . QMARK exp COLON exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for QMARK resolved as shift
<<<<<<< HEAD
    SEMICOLON       reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    COMMA           reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    RPAREN          reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    RCOR            reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    COLON           reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    GT              shift and go to state 119
    GTE             shift and go to state 120
    LT              shift and go to state 121
    LTE             shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    QMARK           shift and go to state 125
=======
    COMMA           reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    RPAREN          reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    SEMICOLON       reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    RCOR            reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    COLON           reduce using rule 57 (exp -> exp QMARK exp COLON exp .)
    PLUS            shift and go to state 123
    MINUS           shift and go to state 122
    MULT            shift and go to state 115
    DIVIDE          shift and go to state 117
    MOD             shift and go to state 127
    EQUALS          shift and go to state 129
    DIFFERENT       shift and go to state 126
    GT              shift and go to state 118
    GTE             shift and go to state 124
    LT              shift and go to state 116
    LTE             shift and go to state 121
    AND             shift and go to state 128
    OR              shift and go to state 125
    QMARK           shift and go to state 119
>>>>>>> master

  ! PLUS            [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! MINUS           [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! MULT            [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! DIVIDE          [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! MOD             [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! EQUALS          [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! DIFFERENT       [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! GT              [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! GTE             [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! LT              [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! LTE             [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! AND             [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! OR              [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]
  ! QMARK           [ reduce using rule 57 (exp -> exp QMARK exp COLON exp .) ]


<<<<<<< HEAD
state 172

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY . ELSE LKEY block RKEY

    error           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    IF              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ELSE            shift and go to state 175


state 173
=======
state 171

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY ELSE LKEY block RKEY

    RKEY            shift and go to state 174


state 172
>>>>>>> master

    (28) whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .

    error           reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    IF              reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 28 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)


<<<<<<< HEAD
state 174

    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 176
=======
state 173

    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 175


state 174

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY . ELSE LKEY block RKEY

    error           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    IF              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ELSE            shift and go to state 176
>>>>>>> master


state 175

<<<<<<< HEAD
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE . LKEY block RKEY
=======
    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN . LKEY block RKEY
>>>>>>> master

    LKEY            shift and go to state 177


state 176

<<<<<<< HEAD
    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN . LKEY block RKEY
=======
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE . LKEY block RKEY
>>>>>>> master

    LKEY            shift and go to state 178


state 177

<<<<<<< HEAD
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY . block RKEY
=======
    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY . block RKEY
>>>>>>> master
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
<<<<<<< HEAD
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 179
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 178

    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY . block RKEY
=======
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    empty                          shift and go to state 49
    block                          shift and go to state 179
    varDec                         shift and go to state 46
    type                           shift and go to state 47
    varDecList                     shift and go to state 48

state 178

    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY . block RKEY
>>>>>>> master
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    error           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
<<<<<<< HEAD
    INT             shift and go to state 7
    STRING          shift and go to state 8
    BOOLEAN         shift and go to state 9

    block                          shift and go to state 180
    varDecList                     shift and go to state 43
    varDec                         shift and go to state 44
    empty                          shift and go to state 45
    type                           shift and go to state 46

state 179

    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block . RKEY
=======
    INT             shift and go to state 1
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 6

    empty                          shift and go to state 49
    block                          shift and go to state 180
    varDec                         shift and go to state 46
    type                           shift and go to state 47
    varDecList                     shift and go to state 48

state 179

    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block . RKEY
>>>>>>> master

    RKEY            shift and go to state 181


state 180

<<<<<<< HEAD
    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block . RKEY
=======
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block . RKEY
>>>>>>> master

    RKEY            shift and go to state 182


state 181

<<<<<<< HEAD
    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .

    error           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    IF              reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WHILE           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    FOR             reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    BREAK           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RETURN          reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    READ            reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WRITE           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    ID              reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RKEY            reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)


state 182

=======
>>>>>>> master
    (29) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .

    error           reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    IF              reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    FOR             reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    READ            reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    ID              reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 29 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)

<<<<<<< HEAD
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MULT in state 126 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 126 resolved as shift
WARNING: shift/reduce conflict for MOD in state 126 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 126 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 126 resolved as shift
WARNING: shift/reduce conflict for GT in state 126 resolved as shift
WARNING: shift/reduce conflict for GTE in state 126 resolved as shift
WARNING: shift/reduce conflict for LT in state 126 resolved as shift
WARNING: shift/reduce conflict for LTE in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 126 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MULT in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for MOD in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 127 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 127 resolved as shift
WARNING: shift/reduce conflict for GT in state 127 resolved as shift
WARNING: shift/reduce conflict for GTE in state 127 resolved as shift
WARNING: shift/reduce conflict for LT in state 127 resolved as shift
WARNING: shift/reduce conflict for LTE in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MULT in state 145 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 145 resolved as shift
WARNING: shift/reduce conflict for MOD in state 145 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 145 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 145 resolved as shift
WARNING: shift/reduce conflict for GT in state 145 resolved as shift
WARNING: shift/reduce conflict for GTE in state 145 resolved as shift
WARNING: shift/reduce conflict for LT in state 145 resolved as shift
WARNING: shift/reduce conflict for LTE in state 145 resolved as shift
WARNING: shift/reduce conflict for AND in state 145 resolved as shift
WARNING: shift/reduce conflict for OR in state 145 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 145 resolved as shift
=======

state 182

    (27) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .

    error           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    IF              reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WHILE           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    FOR             reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    BREAK           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RETURN          reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    READ            reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WRITE           reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    ID              reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RKEY            reduce using rule 27 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MULT in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MOD in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 113 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 113 resolved as shift
WARNING: shift/reduce conflict for GT in state 113 resolved as shift
WARNING: shift/reduce conflict for GTE in state 113 resolved as shift
WARNING: shift/reduce conflict for LT in state 113 resolved as shift
WARNING: shift/reduce conflict for LTE in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MULT in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for MOD in state 114 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 114 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 114 resolved as shift
WARNING: shift/reduce conflict for GT in state 114 resolved as shift
WARNING: shift/reduce conflict for GTE in state 114 resolved as shift
WARNING: shift/reduce conflict for LT in state 114 resolved as shift
WARNING: shift/reduce conflict for LTE in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 114 resolved as shift
>>>>>>> master
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MULT in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MOD in state 146 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 146 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 146 resolved as shift
WARNING: shift/reduce conflict for GT in state 146 resolved as shift
WARNING: shift/reduce conflict for GTE in state 146 resolved as shift
WARNING: shift/reduce conflict for LT in state 146 resolved as shift
WARNING: shift/reduce conflict for LTE in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MULT in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for MOD in state 147 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 147 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 147 resolved as shift
WARNING: shift/reduce conflict for GT in state 147 resolved as shift
WARNING: shift/reduce conflict for GTE in state 147 resolved as shift
WARNING: shift/reduce conflict for LT in state 147 resolved as shift
WARNING: shift/reduce conflict for LTE in state 147 resolved as shift
WARNING: shift/reduce conflict for AND in state 147 resolved as shift
WARNING: shift/reduce conflict for OR in state 147 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MULT in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for MOD in state 148 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 148 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 148 resolved as shift
WARNING: shift/reduce conflict for GT in state 148 resolved as shift
WARNING: shift/reduce conflict for GTE in state 148 resolved as shift
WARNING: shift/reduce conflict for LT in state 148 resolved as shift
WARNING: shift/reduce conflict for LTE in state 148 resolved as shift
WARNING: shift/reduce conflict for AND in state 148 resolved as shift
WARNING: shift/reduce conflict for OR in state 148 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MULT in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for MOD in state 149 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 149 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 149 resolved as shift
WARNING: shift/reduce conflict for GT in state 149 resolved as shift
WARNING: shift/reduce conflict for GTE in state 149 resolved as shift
WARNING: shift/reduce conflict for LT in state 149 resolved as shift
WARNING: shift/reduce conflict for LTE in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for OR in state 149 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 149 resolved as shift
<<<<<<< HEAD
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MULT in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MOD in state 150 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 150 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 150 resolved as shift
WARNING: shift/reduce conflict for GT in state 150 resolved as shift
WARNING: shift/reduce conflict for GTE in state 150 resolved as shift
WARNING: shift/reduce conflict for LT in state 150 resolved as shift
WARNING: shift/reduce conflict for LTE in state 150 resolved as shift
WARNING: shift/reduce conflict for AND in state 150 resolved as shift
WARNING: shift/reduce conflict for OR in state 150 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 150 resolved as shift
=======
>>>>>>> master
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MULT in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for MOD in state 151 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 151 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 151 resolved as shift
WARNING: shift/reduce conflict for GT in state 151 resolved as shift
WARNING: shift/reduce conflict for GTE in state 151 resolved as shift
WARNING: shift/reduce conflict for LT in state 151 resolved as shift
WARNING: shift/reduce conflict for LTE in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MULT in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for MOD in state 152 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 152 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 152 resolved as shift
WARNING: shift/reduce conflict for GT in state 152 resolved as shift
WARNING: shift/reduce conflict for GTE in state 152 resolved as shift
WARNING: shift/reduce conflict for LT in state 152 resolved as shift
WARNING: shift/reduce conflict for LTE in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MULT in state 153 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 153 resolved as shift
WARNING: shift/reduce conflict for MOD in state 153 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 153 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 153 resolved as shift
WARNING: shift/reduce conflict for GT in state 153 resolved as shift
WARNING: shift/reduce conflict for GTE in state 153 resolved as shift
WARNING: shift/reduce conflict for LT in state 153 resolved as shift
WARNING: shift/reduce conflict for LTE in state 153 resolved as shift
WARNING: shift/reduce conflict for AND in state 153 resolved as shift
WARNING: shift/reduce conflict for OR in state 153 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 153 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MULT in state 154 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 154 resolved as shift
WARNING: shift/reduce conflict for MOD in state 154 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 154 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 154 resolved as shift
WARNING: shift/reduce conflict for GT in state 154 resolved as shift
WARNING: shift/reduce conflict for GTE in state 154 resolved as shift
WARNING: shift/reduce conflict for LT in state 154 resolved as shift
WARNING: shift/reduce conflict for LTE in state 154 resolved as shift
WARNING: shift/reduce conflict for AND in state 154 resolved as shift
WARNING: shift/reduce conflict for OR in state 154 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 154 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MULT in state 155 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 155 resolved as shift
WARNING: shift/reduce conflict for MOD in state 155 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 155 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 155 resolved as shift
WARNING: shift/reduce conflict for GT in state 155 resolved as shift
WARNING: shift/reduce conflict for GTE in state 155 resolved as shift
WARNING: shift/reduce conflict for LT in state 155 resolved as shift
WARNING: shift/reduce conflict for LTE in state 155 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for OR in state 155 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MULT in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: shift/reduce conflict for MOD in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 156 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MULT in state 157 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 157 resolved as shift
WARNING: shift/reduce conflict for MOD in state 157 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 157 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 157 resolved as shift
WARNING: shift/reduce conflict for GT in state 157 resolved as shift
WARNING: shift/reduce conflict for GTE in state 157 resolved as shift
WARNING: shift/reduce conflict for LT in state 157 resolved as shift
WARNING: shift/reduce conflict for LTE in state 157 resolved as shift
WARNING: shift/reduce conflict for AND in state 157 resolved as shift
WARNING: shift/reduce conflict for OR in state 157 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 157 resolved as shift
<<<<<<< HEAD
WARNING: shift/reduce conflict for PLUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MULT in state 171 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for MOD in state 171 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 171 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 171 resolved as shift
WARNING: shift/reduce conflict for GT in state 171 resolved as shift
WARNING: shift/reduce conflict for GTE in state 171 resolved as shift
WARNING: shift/reduce conflict for LT in state 171 resolved as shift
WARNING: shift/reduce conflict for LTE in state 171 resolved as shift
WARNING: shift/reduce conflict for AND in state 171 resolved as shift
WARNING: shift/reduce conflict for OR in state 171 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 171 resolved as shift
=======
WARNING: shift/reduce conflict for PLUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MULT in state 158 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 158 resolved as shift
WARNING: shift/reduce conflict for MOD in state 158 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 158 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 158 resolved as shift
WARNING: shift/reduce conflict for GT in state 158 resolved as shift
WARNING: shift/reduce conflict for GTE in state 158 resolved as shift
WARNING: shift/reduce conflict for LT in state 158 resolved as shift
WARNING: shift/reduce conflict for LTE in state 158 resolved as shift
WARNING: shift/reduce conflict for AND in state 158 resolved as shift
WARNING: shift/reduce conflict for OR in state 158 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 158 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for MULT in state 159 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 159 resolved as shift
WARNING: shift/reduce conflict for MOD in state 159 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 159 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 159 resolved as shift
WARNING: shift/reduce conflict for GT in state 159 resolved as shift
WARNING: shift/reduce conflict for GTE in state 159 resolved as shift
WARNING: shift/reduce conflict for LT in state 159 resolved as shift
WARNING: shift/reduce conflict for LTE in state 159 resolved as shift
WARNING: shift/reduce conflict for AND in state 159 resolved as shift
WARNING: shift/reduce conflict for OR in state 159 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 159 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 170 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 170 resolved as shift
WARNING: shift/reduce conflict for MULT in state 170 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 170 resolved as shift
WARNING: shift/reduce conflict for MOD in state 170 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 170 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 170 resolved as shift
WARNING: shift/reduce conflict for GT in state 170 resolved as shift
WARNING: shift/reduce conflict for GTE in state 170 resolved as shift
WARNING: shift/reduce conflict for LT in state 170 resolved as shift
WARNING: shift/reduce conflict for LTE in state 170 resolved as shift
WARNING: shift/reduce conflict for AND in state 170 resolved as shift
WARNING: shift/reduce conflict for OR in state 170 resolved as shift
WARNING: shift/reduce conflict for QMARK in state 170 resolved as shift
>>>>>>> master
