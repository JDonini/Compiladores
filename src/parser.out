Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decSeq
Rule 2     dec -> varDec
Rule 3     dec -> ID LPAREN paramList RPAREN LKEY block RKEY
Rule 4     dec -> type ID LPAREN paramList RPAREN LKEY block RKEY
Rule 5     varDec -> type varSpecSeq SEMICOLON
Rule 6     varSpec -> ID
Rule 7     varSpec -> ID ASSIGN literal
Rule 8     varSpec -> ID LCOR NUMBER RCOR
Rule 9     varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY
Rule 10    type -> INT
Rule 11    type -> STRING
Rule 12    type -> BOOLEAN
Rule 13    param -> type ID
Rule 14    param -> type ID RCOR LCOR
Rule 15    block -> varDecList stmtList
Rule 16    stmt -> ifStmt
Rule 17    stmt -> whileStmt
Rule 18    stmt -> forStmt
Rule 19    stmt -> breakStmt
Rule 20    stmt -> returnStmt
Rule 21    stmt -> readStmt
Rule 22    stmt -> writeStmt
Rule 23    stmt -> assign SEMICOLON
Rule 24    stmt -> subCall SEMICOLON
Rule 25    ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY
Rule 26    ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
Rule 27    whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY
Rule 28    forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
Rule 29    breakStmt -> BREAK SEMICOLON
Rule 30    readStmt -> READ var SEMICOLON
Rule 31    writeStmt -> WRITE expList SEMICOLON
Rule 32    returnStmt -> RETURN SEMICOLON
Rule 33    returnStmt -> RETURN exp SEMICOLON
Rule 34    subCall -> ID LPAREN expList RPAREN
Rule 35    assign -> var ASSIGN exp
Rule 36    assign -> var PLUSASSIGN exp
Rule 37    assign -> var MINUSASSIGN exp
Rule 38    assign -> var MULTASSIGN exp
Rule 39    assign -> var DIVIDEASSIGN exp
Rule 40    assign -> var MODASSIGN exp
Rule 41    exp -> exp PLUS exp
Rule 42    exp -> exp MINUS exp
Rule 43    exp -> exp MULT exp
Rule 44    exp -> exp DIVIDE exp
Rule 45    exp -> exp MOD exp
Rule 46    exp -> exp EQUALS exp
Rule 47    exp -> exp DIFFERENT exp
Rule 48    exp -> exp LTE exp
Rule 49    exp -> exp GTE exp
Rule 50    exp -> exp GT exp
Rule 51    exp -> exp LT exp
Rule 52    exp -> exp AND exp
Rule 53    exp -> exp OR exp
Rule 54    exp -> NOT exp
Rule 55    exp -> UMINUS exp
Rule 56    exp -> exp ? exp : exp
Rule 57    exp -> subCall
Rule 58    exp -> var
Rule 59    exp -> literal
Rule 60    exp -> LPAREN exp RPAREN
Rule 61    var -> ID
Rule 62    var -> ID LCOR exp RCOR
Rule 63    literal -> NUMBER
Rule 64    literal -> STRING_LITERAL
Rule 65    literal -> FALSE
Rule 66    literal -> TRUE
Rule 67    paramList -> paramSeq
Rule 68    paramList -> empty
Rule 69    program -> empty
Rule 70    paramSeq -> param
Rule 71    paramSeq -> param COMMA paramSeq
Rule 72    varDecList -> varDec varDecList
Rule 73    varDecList -> empty
Rule 74    varSpecSeq -> varSpec
Rule 75    varSpecSeq -> varSpec COMMA varSpecSeq
Rule 76    decSeq -> dec
Rule 77    decSeq -> dec decSeq
Rule 78    stmtList -> stmt stmtList
Rule 79    stmtList -> empty
Rule 80    literalSeq -> literal
Rule 81    literalSeq -> literal COMMA literalSeq
Rule 82    expList -> expSeq
Rule 83    expList -> empty
Rule 84    expSeq -> exp
Rule 85    expSeq -> exp COMMA expSeq
Rule 86    empty -> <empty>

Terminals, with rules where they appear

:                    : 56
?                    : 56
AND                  : 52
ASSIGN               : 7 9 35
BOOLEAN              : 12
BREAK                : 29
COMMA                : 71 75 81 85
DIFFERENT            : 47
DIVIDE               : 44
DIVIDEASSIGN         : 39
ELSE                 : 26
EQUALS               : 46
FALSE                : 65
FOR                  : 28
GT                   : 50
GTE                  : 49
ID                   : 3 4 6 7 8 9 13 14 34 61 62
IF                   : 25 26
INT                  : 10
LCOR                 : 8 9 14 62
LKEY                 : 3 4 9 25 26 26 27 28
LPAREN               : 3 4 25 26 27 28 34 60
LT                   : 51
LTE                  : 48
MINUS                : 42
MINUSASSIGN          : 37
MOD                  : 45
MODASSIGN            : 40
MULT                 : 43
MULTASSIGN           : 38
NOT                  : 54
NUMBER               : 8 9 63
OR                   : 53
PLUS                 : 41
PLUSASSIGN           : 36
RCOR                 : 8 9 14 62
READ                 : 30
RETURN               : 32 33
RKEY                 : 3 4 9 25 26 26 27 28
RPAREN               : 3 4 25 26 27 28 34 60
SEMICOLON            : 5 23 24 28 28 29 30 31 32 33
STRING               : 11
STRING_LITERAL       : 64
TRUE                 : 66
UMINUS               : 55
WHILE                : 27
WRITE                : 31
error                : 

Nonterminals, with rules where they appear

assign               : 23 28 28
block                : 3 4 25 26 26 27 28
breakStmt            : 19
dec                  : 76 77
decSeq               : 1 77
empty                : 68 69 73 79 83
exp                  : 25 26 27 28 33 35 36 37 38 39 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 55 56 56 56 60 62 84 85
expList              : 31 34
expSeq               : 82 85
forStmt              : 18
ifStmt               : 16
literal              : 7 59 80 81
literalSeq           : 9 81
param                : 70 71
paramList            : 3 4
paramSeq             : 67 71
program              : 0
readStmt             : 21
returnStmt           : 20
stmt                 : 78
stmtList             : 15 78
subCall              : 24 57
type                 : 4 5 13 14
var                  : 30 35 36 37 38 39 40 58
varDec               : 2 72
varDecList           : 15 72
varSpec              : 74 75
varSpecSeq           : 5 75
whileStmt            : 17
writeStmt            : 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decSeq
    (69) program -> . empty
    (76) decSeq -> . dec
    (77) decSeq -> . dec decSeq
    (86) empty -> .
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    $end            reduce using rule 86 (empty -> .)
    ID              shift and go to state 6
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    program                        shift and go to state 1
    decSeq                         shift and go to state 2
    empty                          shift and go to state 3
    dec                            shift and go to state 4
    varDec                         shift and go to state 5
    type                           shift and go to state 7

state 1

    (0) S' -> program .



state 2

    (1) program -> decSeq .

    $end            reduce using rule 1 (program -> decSeq .)


state 3

    (69) program -> empty .

    $end            reduce using rule 69 (program -> empty .)


state 4

    (76) decSeq -> dec .
    (77) decSeq -> dec . decSeq
    (76) decSeq -> . dec
    (77) decSeq -> . dec decSeq
    (2) dec -> . varDec
    (3) dec -> . ID LPAREN paramList RPAREN LKEY block RKEY
    (4) dec -> . type ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> . type varSpecSeq SEMICOLON
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    $end            reduce using rule 76 (decSeq -> dec .)
    ID              shift and go to state 6
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    dec                            shift and go to state 4
    decSeq                         shift and go to state 11
    varDec                         shift and go to state 5
    type                           shift and go to state 7

state 5

    (2) dec -> varDec .

    ID              reduce using rule 2 (dec -> varDec .)
    INT             reduce using rule 2 (dec -> varDec .)
    STRING          reduce using rule 2 (dec -> varDec .)
    BOOLEAN         reduce using rule 2 (dec -> varDec .)
    $end            reduce using rule 2 (dec -> varDec .)


state 6

    (3) dec -> ID . LPAREN paramList RPAREN LKEY block RKEY

    LPAREN          shift and go to state 12


state 7

    (4) dec -> type . ID LPAREN paramList RPAREN LKEY block RKEY
    (5) varDec -> type . varSpecSeq SEMICOLON
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 13

    varSpecSeq                     shift and go to state 14
    varSpec                        shift and go to state 15

state 8

    (10) type -> INT .

    ID              reduce using rule 10 (type -> INT .)


state 9

    (11) type -> STRING .

    ID              reduce using rule 11 (type -> STRING .)


state 10

    (12) type -> BOOLEAN .

    ID              reduce using rule 12 (type -> BOOLEAN .)


state 11

    (77) decSeq -> dec decSeq .

    $end            reduce using rule 77 (decSeq -> dec decSeq .)


state 12

    (3) dec -> ID LPAREN . paramList RPAREN LKEY block RKEY
    (67) paramList -> . paramSeq
    (68) paramList -> . empty
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    paramList                      shift and go to state 16
    paramSeq                       shift and go to state 17
    empty                          shift and go to state 18
    param                          shift and go to state 19
    type                           shift and go to state 20

state 13

    (4) dec -> type ID . LPAREN paramList RPAREN LKEY block RKEY
    (6) varSpec -> ID .
    (7) varSpec -> ID . ASSIGN literal
    (8) varSpec -> ID . LCOR NUMBER RCOR
    (9) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    LPAREN          shift and go to state 21
    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 22
    LCOR            shift and go to state 23


state 14

    (5) varDec -> type varSpecSeq . SEMICOLON

    SEMICOLON       shift and go to state 24


state 15

    (74) varSpecSeq -> varSpec .
    (75) varSpecSeq -> varSpec . COMMA varSpecSeq

    SEMICOLON       reduce using rule 74 (varSpecSeq -> varSpec .)
    COMMA           shift and go to state 25


state 16

    (3) dec -> ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 26


state 17

    (67) paramList -> paramSeq .

    RPAREN          reduce using rule 67 (paramList -> paramSeq .)


state 18

    (68) paramList -> empty .

    RPAREN          reduce using rule 68 (paramList -> empty .)


state 19

    (70) paramSeq -> param .
    (71) paramSeq -> param . COMMA paramSeq

    RPAREN          reduce using rule 70 (paramSeq -> param .)
    COMMA           shift and go to state 27


state 20

    (13) param -> type . ID
    (14) param -> type . ID RCOR LCOR

    ID              shift and go to state 28


state 21

    (4) dec -> type ID LPAREN . paramList RPAREN LKEY block RKEY
    (67) paramList -> . paramSeq
    (68) paramList -> . empty
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (86) empty -> .
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    RPAREN          reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    type                           shift and go to state 20
    paramList                      shift and go to state 29
    paramSeq                       shift and go to state 17
    empty                          shift and go to state 18
    param                          shift and go to state 19

state 22

    (7) varSpec -> ID ASSIGN . literal
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    literal                        shift and go to state 30

state 23

    (8) varSpec -> ID LCOR . NUMBER RCOR
    (9) varSpec -> ID LCOR . NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    NUMBER          shift and go to state 35


state 24

    (5) varDec -> type varSpecSeq SEMICOLON .

    ID              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    INT             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    STRING          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BOOLEAN         reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    $end            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    IF              reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WHILE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    FOR             reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    BREAK           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RETURN          reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    READ            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    WRITE           reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)
    RKEY            reduce using rule 5 (varDec -> type varSpecSeq SEMICOLON .)


state 25

    (75) varSpecSeq -> varSpec COMMA . varSpecSeq
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 37

    varSpec                        shift and go to state 15
    varSpecSeq                     shift and go to state 36

state 26

    (3) dec -> ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 38


state 27

    (71) paramSeq -> param COMMA . paramSeq
    (70) paramSeq -> . param
    (71) paramSeq -> . param COMMA paramSeq
    (13) param -> . type ID
    (14) param -> . type ID RCOR LCOR
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    param                          shift and go to state 19
    paramSeq                       shift and go to state 39
    type                           shift and go to state 20

state 28

    (13) param -> type ID .
    (14) param -> type ID . RCOR LCOR

    COMMA           reduce using rule 13 (param -> type ID .)
    RPAREN          reduce using rule 13 (param -> type ID .)
    RCOR            shift and go to state 40


state 29

    (4) dec -> type ID LPAREN paramList . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 41


state 30

    (7) varSpec -> ID ASSIGN literal .

    COMMA           reduce using rule 7 (varSpec -> ID ASSIGN literal .)
    SEMICOLON       reduce using rule 7 (varSpec -> ID ASSIGN literal .)


state 31

    (63) literal -> NUMBER .

    COMMA           reduce using rule 63 (literal -> NUMBER .)
    SEMICOLON       reduce using rule 63 (literal -> NUMBER .)
    PLUS            reduce using rule 63 (literal -> NUMBER .)
    MINUS           reduce using rule 63 (literal -> NUMBER .)
    MULT            reduce using rule 63 (literal -> NUMBER .)
    DIVIDE          reduce using rule 63 (literal -> NUMBER .)
    MOD             reduce using rule 63 (literal -> NUMBER .)
    EQUALS          reduce using rule 63 (literal -> NUMBER .)
    DIFFERENT       reduce using rule 63 (literal -> NUMBER .)
    LTE             reduce using rule 63 (literal -> NUMBER .)
    GTE             reduce using rule 63 (literal -> NUMBER .)
    GT              reduce using rule 63 (literal -> NUMBER .)
    LT              reduce using rule 63 (literal -> NUMBER .)
    AND             reduce using rule 63 (literal -> NUMBER .)
    OR              reduce using rule 63 (literal -> NUMBER .)
    ?               reduce using rule 63 (literal -> NUMBER .)
    RKEY            reduce using rule 63 (literal -> NUMBER .)
    RPAREN          reduce using rule 63 (literal -> NUMBER .)
    RCOR            reduce using rule 63 (literal -> NUMBER .)
    :               reduce using rule 63 (literal -> NUMBER .)


state 32

    (64) literal -> STRING_LITERAL .

    COMMA           reduce using rule 64 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 64 (literal -> STRING_LITERAL .)
    PLUS            reduce using rule 64 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 64 (literal -> STRING_LITERAL .)
    MULT            reduce using rule 64 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 64 (literal -> STRING_LITERAL .)
    MOD             reduce using rule 64 (literal -> STRING_LITERAL .)
    EQUALS          reduce using rule 64 (literal -> STRING_LITERAL .)
    DIFFERENT       reduce using rule 64 (literal -> STRING_LITERAL .)
    LTE             reduce using rule 64 (literal -> STRING_LITERAL .)
    GTE             reduce using rule 64 (literal -> STRING_LITERAL .)
    GT              reduce using rule 64 (literal -> STRING_LITERAL .)
    LT              reduce using rule 64 (literal -> STRING_LITERAL .)
    AND             reduce using rule 64 (literal -> STRING_LITERAL .)
    OR              reduce using rule 64 (literal -> STRING_LITERAL .)
    ?               reduce using rule 64 (literal -> STRING_LITERAL .)
    RKEY            reduce using rule 64 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 64 (literal -> STRING_LITERAL .)
    RCOR            reduce using rule 64 (literal -> STRING_LITERAL .)
    :               reduce using rule 64 (literal -> STRING_LITERAL .)


state 33

    (65) literal -> FALSE .

    COMMA           reduce using rule 65 (literal -> FALSE .)
    SEMICOLON       reduce using rule 65 (literal -> FALSE .)
    PLUS            reduce using rule 65 (literal -> FALSE .)
    MINUS           reduce using rule 65 (literal -> FALSE .)
    MULT            reduce using rule 65 (literal -> FALSE .)
    DIVIDE          reduce using rule 65 (literal -> FALSE .)
    MOD             reduce using rule 65 (literal -> FALSE .)
    EQUALS          reduce using rule 65 (literal -> FALSE .)
    DIFFERENT       reduce using rule 65 (literal -> FALSE .)
    LTE             reduce using rule 65 (literal -> FALSE .)
    GTE             reduce using rule 65 (literal -> FALSE .)
    GT              reduce using rule 65 (literal -> FALSE .)
    LT              reduce using rule 65 (literal -> FALSE .)
    AND             reduce using rule 65 (literal -> FALSE .)
    OR              reduce using rule 65 (literal -> FALSE .)
    ?               reduce using rule 65 (literal -> FALSE .)
    RKEY            reduce using rule 65 (literal -> FALSE .)
    RPAREN          reduce using rule 65 (literal -> FALSE .)
    RCOR            reduce using rule 65 (literal -> FALSE .)
    :               reduce using rule 65 (literal -> FALSE .)


state 34

    (66) literal -> TRUE .

    COMMA           reduce using rule 66 (literal -> TRUE .)
    SEMICOLON       reduce using rule 66 (literal -> TRUE .)
    PLUS            reduce using rule 66 (literal -> TRUE .)
    MINUS           reduce using rule 66 (literal -> TRUE .)
    MULT            reduce using rule 66 (literal -> TRUE .)
    DIVIDE          reduce using rule 66 (literal -> TRUE .)
    MOD             reduce using rule 66 (literal -> TRUE .)
    EQUALS          reduce using rule 66 (literal -> TRUE .)
    DIFFERENT       reduce using rule 66 (literal -> TRUE .)
    LTE             reduce using rule 66 (literal -> TRUE .)
    GTE             reduce using rule 66 (literal -> TRUE .)
    GT              reduce using rule 66 (literal -> TRUE .)
    LT              reduce using rule 66 (literal -> TRUE .)
    AND             reduce using rule 66 (literal -> TRUE .)
    OR              reduce using rule 66 (literal -> TRUE .)
    ?               reduce using rule 66 (literal -> TRUE .)
    RKEY            reduce using rule 66 (literal -> TRUE .)
    RPAREN          reduce using rule 66 (literal -> TRUE .)
    RCOR            reduce using rule 66 (literal -> TRUE .)
    :               reduce using rule 66 (literal -> TRUE .)


state 35

    (8) varSpec -> ID LCOR NUMBER . RCOR
    (9) varSpec -> ID LCOR NUMBER . RCOR ASSIGN LKEY literalSeq RKEY

    RCOR            shift and go to state 42


state 36

    (75) varSpecSeq -> varSpec COMMA varSpecSeq .

    SEMICOLON       reduce using rule 75 (varSpecSeq -> varSpec COMMA varSpecSeq .)


state 37

    (6) varSpec -> ID .
    (7) varSpec -> ID . ASSIGN literal
    (8) varSpec -> ID . LCOR NUMBER RCOR
    (9) varSpec -> ID . LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 6 (varSpec -> ID .)
    SEMICOLON       reduce using rule 6 (varSpec -> ID .)
    ASSIGN          shift and go to state 22
    LCOR            shift and go to state 23


state 38

    (3) dec -> ID LPAREN paramList RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    block                          shift and go to state 43
    varDecList                     shift and go to state 44
    varDec                         shift and go to state 45
    empty                          shift and go to state 46
    type                           shift and go to state 47

state 39

    (71) paramSeq -> param COMMA paramSeq .

    RPAREN          reduce using rule 71 (paramSeq -> param COMMA paramSeq .)


state 40

    (14) param -> type ID RCOR . LCOR

    LCOR            shift and go to state 48


state 41

    (4) dec -> type ID LPAREN paramList RPAREN . LKEY block RKEY

    LKEY            shift and go to state 49


state 42

    (8) varSpec -> ID LCOR NUMBER RCOR .
    (9) varSpec -> ID LCOR NUMBER RCOR . ASSIGN LKEY literalSeq RKEY

    COMMA           reduce using rule 8 (varSpec -> ID LCOR NUMBER RCOR .)
    SEMICOLON       reduce using rule 8 (varSpec -> ID LCOR NUMBER RCOR .)
    ASSIGN          shift and go to state 50


state 43

    (3) dec -> ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 51


state 44

    (15) block -> varDecList . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (86) empty -> .
    (25) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (26) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (27) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (28) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (29) breakStmt -> . BREAK SEMICOLON
    (32) returnStmt -> . RETURN SEMICOLON
    (33) returnStmt -> . RETURN exp SEMICOLON
    (30) readStmt -> . READ var SEMICOLON
    (31) writeStmt -> . WRITE expList SEMICOLON
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUSASSIGN exp
    (37) assign -> . var MINUSASSIGN exp
    (38) assign -> . var MULTASSIGN exp
    (39) assign -> . var DIVIDEASSIGN exp
    (40) assign -> . var MODASSIGN exp
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR

    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    BREAK           shift and go to state 67
    RETURN          shift and go to state 68
    READ            shift and go to state 69
    WRITE           shift and go to state 71
    ID              shift and go to state 72

    stmtList                       shift and go to state 52
    stmt                           shift and go to state 53
    empty                          shift and go to state 54
    ifStmt                         shift and go to state 55
    whileStmt                      shift and go to state 56
    forStmt                        shift and go to state 57
    breakStmt                      shift and go to state 58
    returnStmt                     shift and go to state 59
    readStmt                       shift and go to state 60
    writeStmt                      shift and go to state 61
    assign                         shift and go to state 62
    subCall                        shift and go to state 63
    var                            shift and go to state 70

state 45

    (72) varDecList -> varDec . varDecList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    varDec                         shift and go to state 45
    varDecList                     shift and go to state 73
    empty                          shift and go to state 46
    type                           shift and go to state 47

state 46

    (73) varDecList -> empty .

    IF              reduce using rule 73 (varDecList -> empty .)
    WHILE           reduce using rule 73 (varDecList -> empty .)
    FOR             reduce using rule 73 (varDecList -> empty .)
    BREAK           reduce using rule 73 (varDecList -> empty .)
    RETURN          reduce using rule 73 (varDecList -> empty .)
    READ            reduce using rule 73 (varDecList -> empty .)
    WRITE           reduce using rule 73 (varDecList -> empty .)
    ID              reduce using rule 73 (varDecList -> empty .)
    RKEY            reduce using rule 73 (varDecList -> empty .)


state 47

    (5) varDec -> type . varSpecSeq SEMICOLON
    (74) varSpecSeq -> . varSpec
    (75) varSpecSeq -> . varSpec COMMA varSpecSeq
    (6) varSpec -> . ID
    (7) varSpec -> . ID ASSIGN literal
    (8) varSpec -> . ID LCOR NUMBER RCOR
    (9) varSpec -> . ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY

    ID              shift and go to state 37

    varSpecSeq                     shift and go to state 14
    varSpec                        shift and go to state 15

state 48

    (14) param -> type ID RCOR LCOR .

    COMMA           reduce using rule 14 (param -> type ID RCOR LCOR .)
    RPAREN          reduce using rule 14 (param -> type ID RCOR LCOR .)


state 49

    (4) dec -> type ID LPAREN paramList RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    type                           shift and go to state 47
    block                          shift and go to state 74
    varDecList                     shift and go to state 44
    varDec                         shift and go to state 45
    empty                          shift and go to state 46

state 50

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN . LKEY literalSeq RKEY

    LKEY            shift and go to state 75


state 51

    (3) dec -> ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 3 (dec -> ID LPAREN paramList RPAREN LKEY block RKEY .)


state 52

    (15) block -> varDecList stmtList .

    RKEY            reduce using rule 15 (block -> varDecList stmtList .)


state 53

    (78) stmtList -> stmt . stmtList
    (78) stmtList -> . stmt stmtList
    (79) stmtList -> . empty
    (16) stmt -> . ifStmt
    (17) stmt -> . whileStmt
    (18) stmt -> . forStmt
    (19) stmt -> . breakStmt
    (20) stmt -> . returnStmt
    (21) stmt -> . readStmt
    (22) stmt -> . writeStmt
    (23) stmt -> . assign SEMICOLON
    (24) stmt -> . subCall SEMICOLON
    (86) empty -> .
    (25) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY
    (26) ifStmt -> . IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (27) whileStmt -> . WHILE LPAREN exp RPAREN LKEY block RKEY
    (28) forStmt -> . FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (29) breakStmt -> . BREAK SEMICOLON
    (32) returnStmt -> . RETURN SEMICOLON
    (33) returnStmt -> . RETURN exp SEMICOLON
    (30) readStmt -> . READ var SEMICOLON
    (31) writeStmt -> . WRITE expList SEMICOLON
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUSASSIGN exp
    (37) assign -> . var MINUSASSIGN exp
    (38) assign -> . var MULTASSIGN exp
    (39) assign -> . var DIVIDEASSIGN exp
    (40) assign -> . var MODASSIGN exp
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR

    RKEY            reduce using rule 86 (empty -> .)
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    BREAK           shift and go to state 67
    RETURN          shift and go to state 68
    READ            shift and go to state 69
    WRITE           shift and go to state 71
    ID              shift and go to state 72

    stmt                           shift and go to state 53
    stmtList                       shift and go to state 76
    empty                          shift and go to state 54
    ifStmt                         shift and go to state 55
    whileStmt                      shift and go to state 56
    forStmt                        shift and go to state 57
    breakStmt                      shift and go to state 58
    returnStmt                     shift and go to state 59
    readStmt                       shift and go to state 60
    writeStmt                      shift and go to state 61
    assign                         shift and go to state 62
    subCall                        shift and go to state 63
    var                            shift and go to state 70

state 54

    (79) stmtList -> empty .

    RKEY            reduce using rule 79 (stmtList -> empty .)


state 55

    (16) stmt -> ifStmt .

    IF              reduce using rule 16 (stmt -> ifStmt .)
    WHILE           reduce using rule 16 (stmt -> ifStmt .)
    FOR             reduce using rule 16 (stmt -> ifStmt .)
    BREAK           reduce using rule 16 (stmt -> ifStmt .)
    RETURN          reduce using rule 16 (stmt -> ifStmt .)
    READ            reduce using rule 16 (stmt -> ifStmt .)
    WRITE           reduce using rule 16 (stmt -> ifStmt .)
    ID              reduce using rule 16 (stmt -> ifStmt .)
    RKEY            reduce using rule 16 (stmt -> ifStmt .)


state 56

    (17) stmt -> whileStmt .

    IF              reduce using rule 17 (stmt -> whileStmt .)
    WHILE           reduce using rule 17 (stmt -> whileStmt .)
    FOR             reduce using rule 17 (stmt -> whileStmt .)
    BREAK           reduce using rule 17 (stmt -> whileStmt .)
    RETURN          reduce using rule 17 (stmt -> whileStmt .)
    READ            reduce using rule 17 (stmt -> whileStmt .)
    WRITE           reduce using rule 17 (stmt -> whileStmt .)
    ID              reduce using rule 17 (stmt -> whileStmt .)
    RKEY            reduce using rule 17 (stmt -> whileStmt .)


state 57

    (18) stmt -> forStmt .

    IF              reduce using rule 18 (stmt -> forStmt .)
    WHILE           reduce using rule 18 (stmt -> forStmt .)
    FOR             reduce using rule 18 (stmt -> forStmt .)
    BREAK           reduce using rule 18 (stmt -> forStmt .)
    RETURN          reduce using rule 18 (stmt -> forStmt .)
    READ            reduce using rule 18 (stmt -> forStmt .)
    WRITE           reduce using rule 18 (stmt -> forStmt .)
    ID              reduce using rule 18 (stmt -> forStmt .)
    RKEY            reduce using rule 18 (stmt -> forStmt .)


state 58

    (19) stmt -> breakStmt .

    IF              reduce using rule 19 (stmt -> breakStmt .)
    WHILE           reduce using rule 19 (stmt -> breakStmt .)
    FOR             reduce using rule 19 (stmt -> breakStmt .)
    BREAK           reduce using rule 19 (stmt -> breakStmt .)
    RETURN          reduce using rule 19 (stmt -> breakStmt .)
    READ            reduce using rule 19 (stmt -> breakStmt .)
    WRITE           reduce using rule 19 (stmt -> breakStmt .)
    ID              reduce using rule 19 (stmt -> breakStmt .)
    RKEY            reduce using rule 19 (stmt -> breakStmt .)


state 59

    (20) stmt -> returnStmt .

    IF              reduce using rule 20 (stmt -> returnStmt .)
    WHILE           reduce using rule 20 (stmt -> returnStmt .)
    FOR             reduce using rule 20 (stmt -> returnStmt .)
    BREAK           reduce using rule 20 (stmt -> returnStmt .)
    RETURN          reduce using rule 20 (stmt -> returnStmt .)
    READ            reduce using rule 20 (stmt -> returnStmt .)
    WRITE           reduce using rule 20 (stmt -> returnStmt .)
    ID              reduce using rule 20 (stmt -> returnStmt .)
    RKEY            reduce using rule 20 (stmt -> returnStmt .)


state 60

    (21) stmt -> readStmt .

    IF              reduce using rule 21 (stmt -> readStmt .)
    WHILE           reduce using rule 21 (stmt -> readStmt .)
    FOR             reduce using rule 21 (stmt -> readStmt .)
    BREAK           reduce using rule 21 (stmt -> readStmt .)
    RETURN          reduce using rule 21 (stmt -> readStmt .)
    READ            reduce using rule 21 (stmt -> readStmt .)
    WRITE           reduce using rule 21 (stmt -> readStmt .)
    ID              reduce using rule 21 (stmt -> readStmt .)
    RKEY            reduce using rule 21 (stmt -> readStmt .)


state 61

    (22) stmt -> writeStmt .

    IF              reduce using rule 22 (stmt -> writeStmt .)
    WHILE           reduce using rule 22 (stmt -> writeStmt .)
    FOR             reduce using rule 22 (stmt -> writeStmt .)
    BREAK           reduce using rule 22 (stmt -> writeStmt .)
    RETURN          reduce using rule 22 (stmt -> writeStmt .)
    READ            reduce using rule 22 (stmt -> writeStmt .)
    WRITE           reduce using rule 22 (stmt -> writeStmt .)
    ID              reduce using rule 22 (stmt -> writeStmt .)
    RKEY            reduce using rule 22 (stmt -> writeStmt .)


state 62

    (23) stmt -> assign . SEMICOLON

    SEMICOLON       shift and go to state 77


state 63

    (24) stmt -> subCall . SEMICOLON

    SEMICOLON       shift and go to state 78


state 64

    (25) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY
    (26) ifStmt -> IF . LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY

    LPAREN          shift and go to state 79


state 65

    (27) whileStmt -> WHILE . LPAREN exp RPAREN LKEY block RKEY

    LPAREN          shift and go to state 80


state 66

    (28) forStmt -> FOR . LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    LPAREN          shift and go to state 81


state 67

    (29) breakStmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 82


state 68

    (32) returnStmt -> RETURN . SEMICOLON
    (33) returnStmt -> RETURN . exp SEMICOLON
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    SEMICOLON       shift and go to state 83
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 84
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 69

    (30) readStmt -> READ . var SEMICOLON
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    var                            shift and go to state 91

state 70

    (35) assign -> var . ASSIGN exp
    (36) assign -> var . PLUSASSIGN exp
    (37) assign -> var . MINUSASSIGN exp
    (38) assign -> var . MULTASSIGN exp
    (39) assign -> var . DIVIDEASSIGN exp
    (40) assign -> var . MODASSIGN exp

    ASSIGN          shift and go to state 93
    PLUSASSIGN      shift and go to state 94
    MINUSASSIGN     shift and go to state 95
    MULTASSIGN      shift and go to state 96
    DIVIDEASSIGN    shift and go to state 97
    MODASSIGN       shift and go to state 98


state 71

    (31) writeStmt -> WRITE . expList SEMICOLON
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    SEMICOLON       reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    expList                        shift and go to state 99
    expSeq                         shift and go to state 100
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 72

    (34) subCall -> ID . LPAREN expList RPAREN
    (61) var -> ID .
    (62) var -> ID . LCOR exp RCOR

    LPAREN          shift and go to state 103
    ASSIGN          reduce using rule 61 (var -> ID .)
    PLUSASSIGN      reduce using rule 61 (var -> ID .)
    MINUSASSIGN     reduce using rule 61 (var -> ID .)
    MULTASSIGN      reduce using rule 61 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 61 (var -> ID .)
    MODASSIGN       reduce using rule 61 (var -> ID .)
    SEMICOLON       reduce using rule 61 (var -> ID .)
    PLUS            reduce using rule 61 (var -> ID .)
    MINUS           reduce using rule 61 (var -> ID .)
    MULT            reduce using rule 61 (var -> ID .)
    DIVIDE          reduce using rule 61 (var -> ID .)
    MOD             reduce using rule 61 (var -> ID .)
    EQUALS          reduce using rule 61 (var -> ID .)
    DIFFERENT       reduce using rule 61 (var -> ID .)
    LTE             reduce using rule 61 (var -> ID .)
    GTE             reduce using rule 61 (var -> ID .)
    GT              reduce using rule 61 (var -> ID .)
    LT              reduce using rule 61 (var -> ID .)
    AND             reduce using rule 61 (var -> ID .)
    OR              reduce using rule 61 (var -> ID .)
    ?               reduce using rule 61 (var -> ID .)
    COMMA           reduce using rule 61 (var -> ID .)
    RPAREN          reduce using rule 61 (var -> ID .)
    RCOR            reduce using rule 61 (var -> ID .)
    :               reduce using rule 61 (var -> ID .)
    LCOR            shift and go to state 104


state 73

    (72) varDecList -> varDec varDecList .

    IF              reduce using rule 72 (varDecList -> varDec varDecList .)
    WHILE           reduce using rule 72 (varDecList -> varDec varDecList .)
    FOR             reduce using rule 72 (varDecList -> varDec varDecList .)
    BREAK           reduce using rule 72 (varDecList -> varDec varDecList .)
    RETURN          reduce using rule 72 (varDecList -> varDec varDecList .)
    READ            reduce using rule 72 (varDecList -> varDec varDecList .)
    WRITE           reduce using rule 72 (varDecList -> varDec varDecList .)
    ID              reduce using rule 72 (varDecList -> varDec varDecList .)
    RKEY            reduce using rule 72 (varDecList -> varDec varDecList .)


state 74

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block . RKEY

    RKEY            shift and go to state 105


state 75

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY . literalSeq RKEY
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    literalSeq                     shift and go to state 106
    literal                        shift and go to state 107

state 76

    (78) stmtList -> stmt stmtList .

    RKEY            reduce using rule 78 (stmtList -> stmt stmtList .)


state 77

    (23) stmt -> assign SEMICOLON .

    IF              reduce using rule 23 (stmt -> assign SEMICOLON .)
    WHILE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    FOR             reduce using rule 23 (stmt -> assign SEMICOLON .)
    BREAK           reduce using rule 23 (stmt -> assign SEMICOLON .)
    RETURN          reduce using rule 23 (stmt -> assign SEMICOLON .)
    READ            reduce using rule 23 (stmt -> assign SEMICOLON .)
    WRITE           reduce using rule 23 (stmt -> assign SEMICOLON .)
    ID              reduce using rule 23 (stmt -> assign SEMICOLON .)
    RKEY            reduce using rule 23 (stmt -> assign SEMICOLON .)


state 78

    (24) stmt -> subCall SEMICOLON .

    IF              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WHILE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    FOR             reduce using rule 24 (stmt -> subCall SEMICOLON .)
    BREAK           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RETURN          reduce using rule 24 (stmt -> subCall SEMICOLON .)
    READ            reduce using rule 24 (stmt -> subCall SEMICOLON .)
    WRITE           reduce using rule 24 (stmt -> subCall SEMICOLON .)
    ID              reduce using rule 24 (stmt -> subCall SEMICOLON .)
    RKEY            reduce using rule 24 (stmt -> subCall SEMICOLON .)


state 79

    (25) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY
    (26) ifStmt -> IF LPAREN . exp RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 108
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 80

    (27) whileStmt -> WHILE LPAREN . exp RPAREN LKEY block RKEY
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 109
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 81

    (28) forStmt -> FOR LPAREN . assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUSASSIGN exp
    (37) assign -> . var MINUSASSIGN exp
    (38) assign -> . var MULTASSIGN exp
    (39) assign -> . var DIVIDEASSIGN exp
    (40) assign -> . var MODASSIGN exp
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    assign                         shift and go to state 110
    var                            shift and go to state 70

state 82

    (29) breakStmt -> BREAK SEMICOLON .

    IF              reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    READ            reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    WRITE           reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    ID              reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)
    RKEY            reduce using rule 29 (breakStmt -> BREAK SEMICOLON .)


state 83

    (32) returnStmt -> RETURN SEMICOLON .

    IF              reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    READ            reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    WRITE           reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    ID              reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)
    RKEY            reduce using rule 32 (returnStmt -> RETURN SEMICOLON .)


state 84

    (33) returnStmt -> RETURN exp . SEMICOLON
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       shift and go to state 111
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 85

    (54) exp -> NOT . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 126
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 86

    (55) exp -> UMINUS . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 127
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 87

    (57) exp -> subCall .

    SEMICOLON       reduce using rule 57 (exp -> subCall .)
    PLUS            reduce using rule 57 (exp -> subCall .)
    MINUS           reduce using rule 57 (exp -> subCall .)
    MULT            reduce using rule 57 (exp -> subCall .)
    DIVIDE          reduce using rule 57 (exp -> subCall .)
    MOD             reduce using rule 57 (exp -> subCall .)
    EQUALS          reduce using rule 57 (exp -> subCall .)
    DIFFERENT       reduce using rule 57 (exp -> subCall .)
    LTE             reduce using rule 57 (exp -> subCall .)
    GTE             reduce using rule 57 (exp -> subCall .)
    GT              reduce using rule 57 (exp -> subCall .)
    LT              reduce using rule 57 (exp -> subCall .)
    AND             reduce using rule 57 (exp -> subCall .)
    OR              reduce using rule 57 (exp -> subCall .)
    ?               reduce using rule 57 (exp -> subCall .)
    COMMA           reduce using rule 57 (exp -> subCall .)
    RPAREN          reduce using rule 57 (exp -> subCall .)
    RCOR            reduce using rule 57 (exp -> subCall .)
    :               reduce using rule 57 (exp -> subCall .)


state 88

    (58) exp -> var .

    SEMICOLON       reduce using rule 58 (exp -> var .)
    PLUS            reduce using rule 58 (exp -> var .)
    MINUS           reduce using rule 58 (exp -> var .)
    MULT            reduce using rule 58 (exp -> var .)
    DIVIDE          reduce using rule 58 (exp -> var .)
    MOD             reduce using rule 58 (exp -> var .)
    EQUALS          reduce using rule 58 (exp -> var .)
    DIFFERENT       reduce using rule 58 (exp -> var .)
    LTE             reduce using rule 58 (exp -> var .)
    GTE             reduce using rule 58 (exp -> var .)
    GT              reduce using rule 58 (exp -> var .)
    LT              reduce using rule 58 (exp -> var .)
    AND             reduce using rule 58 (exp -> var .)
    OR              reduce using rule 58 (exp -> var .)
    ?               reduce using rule 58 (exp -> var .)
    COMMA           reduce using rule 58 (exp -> var .)
    RPAREN          reduce using rule 58 (exp -> var .)
    RCOR            reduce using rule 58 (exp -> var .)
    :               reduce using rule 58 (exp -> var .)


state 89

    (59) exp -> literal .

    SEMICOLON       reduce using rule 59 (exp -> literal .)
    PLUS            reduce using rule 59 (exp -> literal .)
    MINUS           reduce using rule 59 (exp -> literal .)
    MULT            reduce using rule 59 (exp -> literal .)
    DIVIDE          reduce using rule 59 (exp -> literal .)
    MOD             reduce using rule 59 (exp -> literal .)
    EQUALS          reduce using rule 59 (exp -> literal .)
    DIFFERENT       reduce using rule 59 (exp -> literal .)
    LTE             reduce using rule 59 (exp -> literal .)
    GTE             reduce using rule 59 (exp -> literal .)
    GT              reduce using rule 59 (exp -> literal .)
    LT              reduce using rule 59 (exp -> literal .)
    AND             reduce using rule 59 (exp -> literal .)
    OR              reduce using rule 59 (exp -> literal .)
    ?               reduce using rule 59 (exp -> literal .)
    COMMA           reduce using rule 59 (exp -> literal .)
    RPAREN          reduce using rule 59 (exp -> literal .)
    RCOR            reduce using rule 59 (exp -> literal .)
    :               reduce using rule 59 (exp -> literal .)


state 90

    (60) exp -> LPAREN . exp RPAREN
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 128
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 91

    (30) readStmt -> READ var . SEMICOLON

    SEMICOLON       shift and go to state 129


state 92

    (61) var -> ID .
    (62) var -> ID . LCOR exp RCOR

    SEMICOLON       reduce using rule 61 (var -> ID .)
    ASSIGN          reduce using rule 61 (var -> ID .)
    PLUSASSIGN      reduce using rule 61 (var -> ID .)
    MINUSASSIGN     reduce using rule 61 (var -> ID .)
    MULTASSIGN      reduce using rule 61 (var -> ID .)
    DIVIDEASSIGN    reduce using rule 61 (var -> ID .)
    MODASSIGN       reduce using rule 61 (var -> ID .)
    LCOR            shift and go to state 104


state 93

    (35) assign -> var ASSIGN . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    var                            shift and go to state 88
    exp                            shift and go to state 130
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 94

    (36) assign -> var PLUSASSIGN . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    var                            shift and go to state 88
    exp                            shift and go to state 131
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 95

    (37) assign -> var MINUSASSIGN . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    var                            shift and go to state 88
    exp                            shift and go to state 132
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 96

    (38) assign -> var MULTASSIGN . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    var                            shift and go to state 88
    exp                            shift and go to state 133
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 97

    (39) assign -> var DIVIDEASSIGN . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    var                            shift and go to state 88
    exp                            shift and go to state 134
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 98

    (40) assign -> var MODASSIGN . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    var                            shift and go to state 88
    exp                            shift and go to state 135
    subCall                        shift and go to state 87
    literal                        shift and go to state 89

state 99

    (31) writeStmt -> WRITE expList . SEMICOLON

    SEMICOLON       shift and go to state 136


state 100

    (82) expList -> expSeq .

    SEMICOLON       reduce using rule 82 (expList -> expSeq .)
    RPAREN          reduce using rule 82 (expList -> expSeq .)


state 101

    (83) expList -> empty .

    SEMICOLON       reduce using rule 83 (expList -> empty .)
    RPAREN          reduce using rule 83 (expList -> empty .)


state 102

    (84) expSeq -> exp .
    (85) expSeq -> exp . COMMA expSeq
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 84 (expSeq -> exp .)
    RPAREN          reduce using rule 84 (expSeq -> exp .)
    COMMA           shift and go to state 137
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 103

    (34) subCall -> ID LPAREN . expList RPAREN
    (82) expList -> . expSeq
    (83) expList -> . empty
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (86) empty -> .
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    RPAREN          reduce using rule 86 (empty -> .)
    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    expList                        shift and go to state 138
    expSeq                         shift and go to state 100
    empty                          shift and go to state 101
    exp                            shift and go to state 102
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 104

    (62) var -> ID LCOR . exp RCOR
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 139
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 105

    (4) dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .

    ID              reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    INT             reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    STRING          reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    BOOLEAN         reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)
    $end            reduce using rule 4 (dec -> type ID LPAREN paramList RPAREN LKEY block RKEY .)


state 106

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq . RKEY

    RKEY            shift and go to state 140


state 107

    (80) literalSeq -> literal .
    (81) literalSeq -> literal . COMMA literalSeq

    RKEY            reduce using rule 80 (literalSeq -> literal .)
    COMMA           shift and go to state 141


state 108

    (25) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY
    (26) ifStmt -> IF LPAREN exp . RPAREN LKEY block RKEY ELSE LKEY block RKEY
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    RPAREN          shift and go to state 142
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 109

    (27) whileStmt -> WHILE LPAREN exp . RPAREN LKEY block RKEY
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    RPAREN          shift and go to state 143
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 110

    (28) forStmt -> FOR LPAREN assign . SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY

    SEMICOLON       shift and go to state 144


state 111

    (33) returnStmt -> RETURN exp SEMICOLON .

    IF              reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    WHILE           reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    FOR             reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    BREAK           reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    RETURN          reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    READ            reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    WRITE           reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    ID              reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)
    RKEY            reduce using rule 33 (returnStmt -> RETURN exp SEMICOLON .)


state 112

    (41) exp -> exp PLUS . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 145
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 113

    (42) exp -> exp MINUS . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 146
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 114

    (43) exp -> exp MULT . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 147
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 115

    (44) exp -> exp DIVIDE . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 148
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 116

    (45) exp -> exp MOD . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 149
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 117

    (46) exp -> exp EQUALS . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 150
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 118

    (47) exp -> exp DIFFERENT . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 151
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 119

    (48) exp -> exp LTE . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 152
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 120

    (49) exp -> exp GTE . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 153
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 121

    (50) exp -> exp GT . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 154
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 122

    (51) exp -> exp LT . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 155
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 123

    (52) exp -> exp AND . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 156
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 124

    (53) exp -> exp OR . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 157
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 125

    (56) exp -> exp ? . exp : exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 158
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 126

    (54) exp -> NOT exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 54 (exp -> NOT exp .)
    COMMA           reduce using rule 54 (exp -> NOT exp .)
    RPAREN          reduce using rule 54 (exp -> NOT exp .)
    RCOR            reduce using rule 54 (exp -> NOT exp .)
    :               reduce using rule 54 (exp -> NOT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 54 (exp -> NOT exp .) ]
  ! MINUS           [ reduce using rule 54 (exp -> NOT exp .) ]
  ! MULT            [ reduce using rule 54 (exp -> NOT exp .) ]
  ! DIVIDE          [ reduce using rule 54 (exp -> NOT exp .) ]
  ! MOD             [ reduce using rule 54 (exp -> NOT exp .) ]
  ! EQUALS          [ reduce using rule 54 (exp -> NOT exp .) ]
  ! DIFFERENT       [ reduce using rule 54 (exp -> NOT exp .) ]
  ! LTE             [ reduce using rule 54 (exp -> NOT exp .) ]
  ! GTE             [ reduce using rule 54 (exp -> NOT exp .) ]
  ! GT              [ reduce using rule 54 (exp -> NOT exp .) ]
  ! LT              [ reduce using rule 54 (exp -> NOT exp .) ]
  ! AND             [ reduce using rule 54 (exp -> NOT exp .) ]
  ! OR              [ reduce using rule 54 (exp -> NOT exp .) ]
  ! ?               [ reduce using rule 54 (exp -> NOT exp .) ]


state 127

    (55) exp -> UMINUS exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 55 (exp -> UMINUS exp .)
    COMMA           reduce using rule 55 (exp -> UMINUS exp .)
    RPAREN          reduce using rule 55 (exp -> UMINUS exp .)
    RCOR            reduce using rule 55 (exp -> UMINUS exp .)
    :               reduce using rule 55 (exp -> UMINUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! MINUS           [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! MULT            [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! MOD             [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! EQUALS          [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! LTE             [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! GTE             [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! GT              [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! LT              [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! AND             [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! OR              [ reduce using rule 55 (exp -> UMINUS exp .) ]
  ! ?               [ reduce using rule 55 (exp -> UMINUS exp .) ]


state 128

    (60) exp -> LPAREN exp . RPAREN
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    RPAREN          shift and go to state 159
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 129

    (30) readStmt -> READ var SEMICOLON .

    IF              reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    WHILE           reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    FOR             reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    BREAK           reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    RETURN          reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    READ            reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    WRITE           reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    ID              reduce using rule 30 (readStmt -> READ var SEMICOLON .)
    RKEY            reduce using rule 30 (readStmt -> READ var SEMICOLON .)


state 130

    (35) assign -> var ASSIGN exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 35 (assign -> var ASSIGN exp .)
    RPAREN          reduce using rule 35 (assign -> var ASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 131

    (36) assign -> var PLUSASSIGN exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 36 (assign -> var PLUSASSIGN exp .)
    RPAREN          reduce using rule 36 (assign -> var PLUSASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 132

    (37) assign -> var MINUSASSIGN exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 37 (assign -> var MINUSASSIGN exp .)
    RPAREN          reduce using rule 37 (assign -> var MINUSASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 133

    (38) assign -> var MULTASSIGN exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 38 (assign -> var MULTASSIGN exp .)
    RPAREN          reduce using rule 38 (assign -> var MULTASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 134

    (39) assign -> var DIVIDEASSIGN exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 39 (assign -> var DIVIDEASSIGN exp .)
    RPAREN          reduce using rule 39 (assign -> var DIVIDEASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 135

    (40) assign -> var MODASSIGN exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       reduce using rule 40 (assign -> var MODASSIGN exp .)
    RPAREN          reduce using rule 40 (assign -> var MODASSIGN exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 136

    (31) writeStmt -> WRITE expList SEMICOLON .

    IF              reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    WHILE           reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    FOR             reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    BREAK           reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    RETURN          reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    READ            reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    WRITE           reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    ID              reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)
    RKEY            reduce using rule 31 (writeStmt -> WRITE expList SEMICOLON .)


state 137

    (85) expSeq -> exp COMMA . expSeq
    (84) expSeq -> . exp
    (85) expSeq -> . exp COMMA expSeq
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 102
    expSeq                         shift and go to state 160
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 138

    (34) subCall -> ID LPAREN expList . RPAREN

    RPAREN          shift and go to state 161


state 139

    (62) var -> ID LCOR exp . RCOR
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    RCOR            shift and go to state 162
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 140

    (9) varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .

    COMMA           reduce using rule 9 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)
    SEMICOLON       reduce using rule 9 (varSpec -> ID LCOR NUMBER RCOR ASSIGN LKEY literalSeq RKEY .)


state 141

    (81) literalSeq -> literal COMMA . literalSeq
    (80) literalSeq -> . literal
    (81) literalSeq -> . literal COMMA literalSeq
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    literal                        shift and go to state 107
    literalSeq                     shift and go to state 163

state 142

    (25) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY
    (26) ifStmt -> IF LPAREN exp RPAREN . LKEY block RKEY ELSE LKEY block RKEY

    LKEY            shift and go to state 164


state 143

    (27) whileStmt -> WHILE LPAREN exp RPAREN . LKEY block RKEY

    LKEY            shift and go to state 165


state 144

    (28) forStmt -> FOR LPAREN assign SEMICOLON . exp SEMICOLON assign RPAREN LKEY block RKEY
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 166
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 145

    (41) exp -> exp PLUS exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 41 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 41 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 41 (exp -> exp PLUS exp .)
    RCOR            reduce using rule 41 (exp -> exp PLUS exp .)
    :               reduce using rule 41 (exp -> exp PLUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! MINUS           [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! MULT            [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! MOD             [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! EQUALS          [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! DIFFERENT       [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! LTE             [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! GTE             [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! GT              [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! LT              [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! AND             [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! OR              [ reduce using rule 41 (exp -> exp PLUS exp .) ]
  ! ?               [ reduce using rule 41 (exp -> exp PLUS exp .) ]


state 146

    (42) exp -> exp MINUS exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 42 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 42 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 42 (exp -> exp MINUS exp .)
    RCOR            reduce using rule 42 (exp -> exp MINUS exp .)
    :               reduce using rule 42 (exp -> exp MINUS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! MINUS           [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! MULT            [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! MOD             [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! EQUALS          [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! DIFFERENT       [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! LTE             [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! GTE             [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! GT              [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! LT              [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! AND             [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! OR              [ reduce using rule 42 (exp -> exp MINUS exp .) ]
  ! ?               [ reduce using rule 42 (exp -> exp MINUS exp .) ]


state 147

    (43) exp -> exp MULT exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 43 (exp -> exp MULT exp .)
    COMMA           reduce using rule 43 (exp -> exp MULT exp .)
    RPAREN          reduce using rule 43 (exp -> exp MULT exp .)
    RCOR            reduce using rule 43 (exp -> exp MULT exp .)
    :               reduce using rule 43 (exp -> exp MULT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! MINUS           [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! MULT            [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! DIVIDE          [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! MOD             [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! EQUALS          [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! DIFFERENT       [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! LTE             [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! GTE             [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! GT              [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! LT              [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! AND             [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! OR              [ reduce using rule 43 (exp -> exp MULT exp .) ]
  ! ?               [ reduce using rule 43 (exp -> exp MULT exp .) ]


state 148

    (44) exp -> exp DIVIDE exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 44 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 44 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 44 (exp -> exp DIVIDE exp .)
    RCOR            reduce using rule 44 (exp -> exp DIVIDE exp .)
    :               reduce using rule 44 (exp -> exp DIVIDE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! MINUS           [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! MULT            [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! DIVIDE          [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! MOD             [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! EQUALS          [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! DIFFERENT       [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! LTE             [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! GTE             [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! GT              [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! LT              [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! AND             [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! OR              [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]
  ! ?               [ reduce using rule 44 (exp -> exp DIVIDE exp .) ]


state 149

    (45) exp -> exp MOD exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 45 (exp -> exp MOD exp .)
    COMMA           reduce using rule 45 (exp -> exp MOD exp .)
    RPAREN          reduce using rule 45 (exp -> exp MOD exp .)
    RCOR            reduce using rule 45 (exp -> exp MOD exp .)
    :               reduce using rule 45 (exp -> exp MOD exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! MINUS           [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! MULT            [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! DIVIDE          [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! MOD             [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! EQUALS          [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! DIFFERENT       [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! LTE             [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! GTE             [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! GT              [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! LT              [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! AND             [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! OR              [ reduce using rule 45 (exp -> exp MOD exp .) ]
  ! ?               [ reduce using rule 45 (exp -> exp MOD exp .) ]


state 150

    (46) exp -> exp EQUALS exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 46 (exp -> exp EQUALS exp .)
    COMMA           reduce using rule 46 (exp -> exp EQUALS exp .)
    RPAREN          reduce using rule 46 (exp -> exp EQUALS exp .)
    RCOR            reduce using rule 46 (exp -> exp EQUALS exp .)
    :               reduce using rule 46 (exp -> exp EQUALS exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! MINUS           [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! MULT            [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! DIVIDE          [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! MOD             [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! EQUALS          [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! DIFFERENT       [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! LTE             [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! GTE             [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! GT              [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! LT              [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! AND             [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! OR              [ reduce using rule 46 (exp -> exp EQUALS exp .) ]
  ! ?               [ reduce using rule 46 (exp -> exp EQUALS exp .) ]


state 151

    (47) exp -> exp DIFFERENT exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 47 (exp -> exp DIFFERENT exp .)
    COMMA           reduce using rule 47 (exp -> exp DIFFERENT exp .)
    RPAREN          reduce using rule 47 (exp -> exp DIFFERENT exp .)
    RCOR            reduce using rule 47 (exp -> exp DIFFERENT exp .)
    :               reduce using rule 47 (exp -> exp DIFFERENT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! MINUS           [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! MULT            [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! DIVIDE          [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! MOD             [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! EQUALS          [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! DIFFERENT       [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! LTE             [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! GTE             [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! GT              [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! LT              [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! AND             [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! OR              [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]
  ! ?               [ reduce using rule 47 (exp -> exp DIFFERENT exp .) ]


state 152

    (48) exp -> exp LTE exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 48 (exp -> exp LTE exp .)
    COMMA           reduce using rule 48 (exp -> exp LTE exp .)
    RPAREN          reduce using rule 48 (exp -> exp LTE exp .)
    RCOR            reduce using rule 48 (exp -> exp LTE exp .)
    :               reduce using rule 48 (exp -> exp LTE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! MULT            [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! MOD             [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! EQUALS          [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! DIFFERENT       [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! LTE             [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! GTE             [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! GT              [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! LT              [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! AND             [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! OR              [ reduce using rule 48 (exp -> exp LTE exp .) ]
  ! ?               [ reduce using rule 48 (exp -> exp LTE exp .) ]


state 153

    (49) exp -> exp GTE exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> exp GTE exp .)
    COMMA           reduce using rule 49 (exp -> exp GTE exp .)
    RPAREN          reduce using rule 49 (exp -> exp GTE exp .)
    RCOR            reduce using rule 49 (exp -> exp GTE exp .)
    :               reduce using rule 49 (exp -> exp GTE exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! MINUS           [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! MULT            [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! MOD             [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! EQUALS          [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! DIFFERENT       [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! LTE             [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! GTE             [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! GT              [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! LT              [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! AND             [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! OR              [ reduce using rule 49 (exp -> exp GTE exp .) ]
  ! ?               [ reduce using rule 49 (exp -> exp GTE exp .) ]


state 154

    (50) exp -> exp GT exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 50 (exp -> exp GT exp .)
    COMMA           reduce using rule 50 (exp -> exp GT exp .)
    RPAREN          reduce using rule 50 (exp -> exp GT exp .)
    RCOR            reduce using rule 50 (exp -> exp GT exp .)
    :               reduce using rule 50 (exp -> exp GT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! MULT            [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! MOD             [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! EQUALS          [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! DIFFERENT       [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! LTE             [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! GTE             [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! GT              [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! LT              [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! AND             [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! OR              [ reduce using rule 50 (exp -> exp GT exp .) ]
  ! ?               [ reduce using rule 50 (exp -> exp GT exp .) ]


state 155

    (51) exp -> exp LT exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 51 (exp -> exp LT exp .)
    COMMA           reduce using rule 51 (exp -> exp LT exp .)
    RPAREN          reduce using rule 51 (exp -> exp LT exp .)
    RCOR            reduce using rule 51 (exp -> exp LT exp .)
    :               reduce using rule 51 (exp -> exp LT exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MULT            [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! MOD             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! EQUALS          [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! DIFFERENT       [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! LTE             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! GTE             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! GT              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! LT              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! AND             [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! OR              [ reduce using rule 51 (exp -> exp LT exp .) ]
  ! ?               [ reduce using rule 51 (exp -> exp LT exp .) ]


state 156

    (52) exp -> exp AND exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 52 (exp -> exp AND exp .)
    COMMA           reduce using rule 52 (exp -> exp AND exp .)
    RPAREN          reduce using rule 52 (exp -> exp AND exp .)
    RCOR            reduce using rule 52 (exp -> exp AND exp .)
    :               reduce using rule 52 (exp -> exp AND exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! MULT            [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! MOD             [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! EQUALS          [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! DIFFERENT       [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! LTE             [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! GTE             [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! AND             [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! OR              [ reduce using rule 52 (exp -> exp AND exp .) ]
  ! ?               [ reduce using rule 52 (exp -> exp AND exp .) ]


state 157

    (53) exp -> exp OR exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 53 (exp -> exp OR exp .)
    COMMA           reduce using rule 53 (exp -> exp OR exp .)
    RPAREN          reduce using rule 53 (exp -> exp OR exp .)
    RCOR            reduce using rule 53 (exp -> exp OR exp .)
    :               reduce using rule 53 (exp -> exp OR exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! MULT            [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! MOD             [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! EQUALS          [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! DIFFERENT       [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! LTE             [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! GTE             [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! OR              [ reduce using rule 53 (exp -> exp OR exp .) ]
  ! ?               [ reduce using rule 53 (exp -> exp OR exp .) ]


state 158

    (56) exp -> exp ? exp . : exp
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    :               shift and go to state 167
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 159

    (60) exp -> LPAREN exp RPAREN .

    SEMICOLON       reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    MULT            reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    MOD             reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    EQUALS          reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    DIFFERENT       reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    OR              reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    ?               reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    RCOR            reduce using rule 60 (exp -> LPAREN exp RPAREN .)
    :               reduce using rule 60 (exp -> LPAREN exp RPAREN .)


state 160

    (85) expSeq -> exp COMMA expSeq .

    SEMICOLON       reduce using rule 85 (expSeq -> exp COMMA expSeq .)
    RPAREN          reduce using rule 85 (expSeq -> exp COMMA expSeq .)


state 161

    (34) subCall -> ID LPAREN expList RPAREN .

    SEMICOLON       reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    PLUS            reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    MINUS           reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    MULT            reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    DIVIDE          reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    MOD             reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    EQUALS          reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    DIFFERENT       reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    LTE             reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    GTE             reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    GT              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    LT              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    AND             reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    OR              reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    ?               reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    COMMA           reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    RPAREN          reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    RCOR            reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)
    :               reduce using rule 34 (subCall -> ID LPAREN expList RPAREN .)


state 162

    (62) var -> ID LCOR exp RCOR .

    ASSIGN          reduce using rule 62 (var -> ID LCOR exp RCOR .)
    PLUSASSIGN      reduce using rule 62 (var -> ID LCOR exp RCOR .)
    MINUSASSIGN     reduce using rule 62 (var -> ID LCOR exp RCOR .)
    MULTASSIGN      reduce using rule 62 (var -> ID LCOR exp RCOR .)
    DIVIDEASSIGN    reduce using rule 62 (var -> ID LCOR exp RCOR .)
    MODASSIGN       reduce using rule 62 (var -> ID LCOR exp RCOR .)
    SEMICOLON       reduce using rule 62 (var -> ID LCOR exp RCOR .)
    PLUS            reduce using rule 62 (var -> ID LCOR exp RCOR .)
    MINUS           reduce using rule 62 (var -> ID LCOR exp RCOR .)
    MULT            reduce using rule 62 (var -> ID LCOR exp RCOR .)
    DIVIDE          reduce using rule 62 (var -> ID LCOR exp RCOR .)
    MOD             reduce using rule 62 (var -> ID LCOR exp RCOR .)
    EQUALS          reduce using rule 62 (var -> ID LCOR exp RCOR .)
    DIFFERENT       reduce using rule 62 (var -> ID LCOR exp RCOR .)
    LTE             reduce using rule 62 (var -> ID LCOR exp RCOR .)
    GTE             reduce using rule 62 (var -> ID LCOR exp RCOR .)
    GT              reduce using rule 62 (var -> ID LCOR exp RCOR .)
    LT              reduce using rule 62 (var -> ID LCOR exp RCOR .)
    AND             reduce using rule 62 (var -> ID LCOR exp RCOR .)
    OR              reduce using rule 62 (var -> ID LCOR exp RCOR .)
    ?               reduce using rule 62 (var -> ID LCOR exp RCOR .)
    COMMA           reduce using rule 62 (var -> ID LCOR exp RCOR .)
    RPAREN          reduce using rule 62 (var -> ID LCOR exp RCOR .)
    RCOR            reduce using rule 62 (var -> ID LCOR exp RCOR .)
    :               reduce using rule 62 (var -> ID LCOR exp RCOR .)


state 163

    (81) literalSeq -> literal COMMA literalSeq .

    RKEY            reduce using rule 81 (literalSeq -> literal COMMA literalSeq .)


state 164

    (25) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY
    (26) ifStmt -> IF LPAREN exp RPAREN LKEY . block RKEY ELSE LKEY block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    block                          shift and go to state 168
    varDecList                     shift and go to state 44
    varDec                         shift and go to state 45
    empty                          shift and go to state 46
    type                           shift and go to state 47

state 165

    (27) whileStmt -> WHILE LPAREN exp RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    block                          shift and go to state 169
    varDecList                     shift and go to state 44
    varDec                         shift and go to state 45
    empty                          shift and go to state 46
    type                           shift and go to state 47

state 166

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp . SEMICOLON assign RPAREN LKEY block RKEY
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

    SEMICOLON       shift and go to state 170
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125


state 167

    (56) exp -> exp ? exp : . exp
    (41) exp -> . exp PLUS exp
    (42) exp -> . exp MINUS exp
    (43) exp -> . exp MULT exp
    (44) exp -> . exp DIVIDE exp
    (45) exp -> . exp MOD exp
    (46) exp -> . exp EQUALS exp
    (47) exp -> . exp DIFFERENT exp
    (48) exp -> . exp LTE exp
    (49) exp -> . exp GTE exp
    (50) exp -> . exp GT exp
    (51) exp -> . exp LT exp
    (52) exp -> . exp AND exp
    (53) exp -> . exp OR exp
    (54) exp -> . NOT exp
    (55) exp -> . UMINUS exp
    (56) exp -> . exp ? exp : exp
    (57) exp -> . subCall
    (58) exp -> . var
    (59) exp -> . literal
    (60) exp -> . LPAREN exp RPAREN
    (34) subCall -> . ID LPAREN expList RPAREN
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR
    (63) literal -> . NUMBER
    (64) literal -> . STRING_LITERAL
    (65) literal -> . FALSE
    (66) literal -> . TRUE

    NOT             shift and go to state 85
    UMINUS          shift and go to state 86
    LPAREN          shift and go to state 90
    ID              shift and go to state 72
    NUMBER          shift and go to state 31
    STRING_LITERAL  shift and go to state 32
    FALSE           shift and go to state 33
    TRUE            shift and go to state 34

    exp                            shift and go to state 171
    subCall                        shift and go to state 87
    var                            shift and go to state 88
    literal                        shift and go to state 89

state 168

    (25) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY
    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block . RKEY ELSE LKEY block RKEY

    RKEY            shift and go to state 172


state 169

    (27) whileStmt -> WHILE LPAREN exp RPAREN LKEY block . RKEY

    RKEY            shift and go to state 173


state 170

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON . assign RPAREN LKEY block RKEY
    (35) assign -> . var ASSIGN exp
    (36) assign -> . var PLUSASSIGN exp
    (37) assign -> . var MINUSASSIGN exp
    (38) assign -> . var MULTASSIGN exp
    (39) assign -> . var DIVIDEASSIGN exp
    (40) assign -> . var MODASSIGN exp
    (61) var -> . ID
    (62) var -> . ID LCOR exp RCOR

    ID              shift and go to state 92

    assign                         shift and go to state 174
    var                            shift and go to state 70

state 171

    (56) exp -> exp ? exp : exp .
    (41) exp -> exp . PLUS exp
    (42) exp -> exp . MINUS exp
    (43) exp -> exp . MULT exp
    (44) exp -> exp . DIVIDE exp
    (45) exp -> exp . MOD exp
    (46) exp -> exp . EQUALS exp
    (47) exp -> exp . DIFFERENT exp
    (48) exp -> exp . LTE exp
    (49) exp -> exp . GTE exp
    (50) exp -> exp . GT exp
    (51) exp -> exp . LT exp
    (52) exp -> exp . AND exp
    (53) exp -> exp . OR exp
    (56) exp -> exp . ? exp : exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
  ! shift/reduce conflict for LTE resolved as shift
  ! shift/reduce conflict for GTE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEMICOLON       reduce using rule 56 (exp -> exp ? exp : exp .)
    COMMA           reduce using rule 56 (exp -> exp ? exp : exp .)
    RPAREN          reduce using rule 56 (exp -> exp ? exp : exp .)
    RCOR            reduce using rule 56 (exp -> exp ? exp : exp .)
    :               reduce using rule 56 (exp -> exp ? exp : exp .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    MULT            shift and go to state 114
    DIVIDE          shift and go to state 115
    MOD             shift and go to state 116
    EQUALS          shift and go to state 117
    DIFFERENT       shift and go to state 118
    LTE             shift and go to state 119
    GTE             shift and go to state 120
    GT              shift and go to state 121
    LT              shift and go to state 122
    AND             shift and go to state 123
    OR              shift and go to state 124
    ?               shift and go to state 125

  ! PLUS            [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! MULT            [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! MOD             [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! EQUALS          [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! DIFFERENT       [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! LTE             [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! GTE             [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! GT              [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! LT              [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! AND             [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! OR              [ reduce using rule 56 (exp -> exp ? exp : exp .) ]
  ! ?               [ reduce using rule 56 (exp -> exp ? exp : exp .) ]


state 172

    (25) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .
    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY . ELSE LKEY block RKEY

    IF              reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 25 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY .)
    ELSE            shift and go to state 175


state 173

    (27) whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .

    IF              reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    FOR             reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    READ            reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    ID              reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 27 (whileStmt -> WHILE LPAREN exp RPAREN LKEY block RKEY .)


state 174

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign . RPAREN LKEY block RKEY

    RPAREN          shift and go to state 176


state 175

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE . LKEY block RKEY

    LKEY            shift and go to state 177


state 176

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN . LKEY block RKEY

    LKEY            shift and go to state 178


state 177

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    block                          shift and go to state 179
    varDecList                     shift and go to state 44
    varDec                         shift and go to state 45
    empty                          shift and go to state 46
    type                           shift and go to state 47

state 178

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY . block RKEY
    (15) block -> . varDecList stmtList
    (72) varDecList -> . varDec varDecList
    (73) varDecList -> . empty
    (5) varDec -> . type varSpecSeq SEMICOLON
    (86) empty -> .
    (10) type -> . INT
    (11) type -> . STRING
    (12) type -> . BOOLEAN

    IF              reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    BREAK           reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    ID              reduce using rule 86 (empty -> .)
    RKEY            reduce using rule 86 (empty -> .)
    INT             shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10

    block                          shift and go to state 180
    varDecList                     shift and go to state 44
    varDec                         shift and go to state 45
    empty                          shift and go to state 46
    type                           shift and go to state 47

state 179

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block . RKEY

    RKEY            shift and go to state 181


state 180

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block . RKEY

    RKEY            shift and go to state 182


state 181

    (26) ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .

    IF              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WHILE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    FOR             reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    BREAK           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RETURN          reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    READ            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    WRITE           reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    ID              reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)
    RKEY            reduce using rule 26 (ifStmt -> IF LPAREN exp RPAREN LKEY block RKEY ELSE LKEY block RKEY .)


state 182

    (28) forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .

    IF              reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    WHILE           reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    FOR             reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    BREAK           reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    RETURN          reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    READ            reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    WRITE           reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    ID              reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)
    RKEY            reduce using rule 28 (forStmt -> FOR LPAREN assign SEMICOLON exp SEMICOLON assign RPAREN LKEY block RKEY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for MULT in state 126 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 126 resolved as shift
WARNING: shift/reduce conflict for MOD in state 126 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 126 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 126 resolved as shift
WARNING: shift/reduce conflict for LTE in state 126 resolved as shift
WARNING: shift/reduce conflict for GTE in state 126 resolved as shift
WARNING: shift/reduce conflict for GT in state 126 resolved as shift
WARNING: shift/reduce conflict for LT in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for ? in state 126 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MULT in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for MOD in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 127 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 127 resolved as shift
WARNING: shift/reduce conflict for LTE in state 127 resolved as shift
WARNING: shift/reduce conflict for GTE in state 127 resolved as shift
WARNING: shift/reduce conflict for GT in state 127 resolved as shift
WARNING: shift/reduce conflict for LT in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for ? in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MULT in state 145 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 145 resolved as shift
WARNING: shift/reduce conflict for MOD in state 145 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 145 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 145 resolved as shift
WARNING: shift/reduce conflict for LTE in state 145 resolved as shift
WARNING: shift/reduce conflict for GTE in state 145 resolved as shift
WARNING: shift/reduce conflict for GT in state 145 resolved as shift
WARNING: shift/reduce conflict for LT in state 145 resolved as shift
WARNING: shift/reduce conflict for AND in state 145 resolved as shift
WARNING: shift/reduce conflict for OR in state 145 resolved as shift
WARNING: shift/reduce conflict for ? in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MULT in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MOD in state 146 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 146 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 146 resolved as shift
WARNING: shift/reduce conflict for LTE in state 146 resolved as shift
WARNING: shift/reduce conflict for GTE in state 146 resolved as shift
WARNING: shift/reduce conflict for GT in state 146 resolved as shift
WARNING: shift/reduce conflict for LT in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for ? in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MULT in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for MOD in state 147 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 147 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 147 resolved as shift
WARNING: shift/reduce conflict for LTE in state 147 resolved as shift
WARNING: shift/reduce conflict for GTE in state 147 resolved as shift
WARNING: shift/reduce conflict for GT in state 147 resolved as shift
WARNING: shift/reduce conflict for LT in state 147 resolved as shift
WARNING: shift/reduce conflict for AND in state 147 resolved as shift
WARNING: shift/reduce conflict for OR in state 147 resolved as shift
WARNING: shift/reduce conflict for ? in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MULT in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for MOD in state 148 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 148 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 148 resolved as shift
WARNING: shift/reduce conflict for LTE in state 148 resolved as shift
WARNING: shift/reduce conflict for GTE in state 148 resolved as shift
WARNING: shift/reduce conflict for GT in state 148 resolved as shift
WARNING: shift/reduce conflict for LT in state 148 resolved as shift
WARNING: shift/reduce conflict for AND in state 148 resolved as shift
WARNING: shift/reduce conflict for OR in state 148 resolved as shift
WARNING: shift/reduce conflict for ? in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MULT in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for MOD in state 149 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 149 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 149 resolved as shift
WARNING: shift/reduce conflict for LTE in state 149 resolved as shift
WARNING: shift/reduce conflict for GTE in state 149 resolved as shift
WARNING: shift/reduce conflict for GT in state 149 resolved as shift
WARNING: shift/reduce conflict for LT in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for OR in state 149 resolved as shift
WARNING: shift/reduce conflict for ? in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MULT in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MOD in state 150 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 150 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 150 resolved as shift
WARNING: shift/reduce conflict for LTE in state 150 resolved as shift
WARNING: shift/reduce conflict for GTE in state 150 resolved as shift
WARNING: shift/reduce conflict for GT in state 150 resolved as shift
WARNING: shift/reduce conflict for LT in state 150 resolved as shift
WARNING: shift/reduce conflict for AND in state 150 resolved as shift
WARNING: shift/reduce conflict for OR in state 150 resolved as shift
WARNING: shift/reduce conflict for ? in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MULT in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for MOD in state 151 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 151 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 151 resolved as shift
WARNING: shift/reduce conflict for LTE in state 151 resolved as shift
WARNING: shift/reduce conflict for GTE in state 151 resolved as shift
WARNING: shift/reduce conflict for GT in state 151 resolved as shift
WARNING: shift/reduce conflict for LT in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for ? in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MULT in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for MOD in state 152 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 152 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 152 resolved as shift
WARNING: shift/reduce conflict for LTE in state 152 resolved as shift
WARNING: shift/reduce conflict for GTE in state 152 resolved as shift
WARNING: shift/reduce conflict for GT in state 152 resolved as shift
WARNING: shift/reduce conflict for LT in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for ? in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MULT in state 153 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 153 resolved as shift
WARNING: shift/reduce conflict for MOD in state 153 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 153 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 153 resolved as shift
WARNING: shift/reduce conflict for LTE in state 153 resolved as shift
WARNING: shift/reduce conflict for GTE in state 153 resolved as shift
WARNING: shift/reduce conflict for GT in state 153 resolved as shift
WARNING: shift/reduce conflict for LT in state 153 resolved as shift
WARNING: shift/reduce conflict for AND in state 153 resolved as shift
WARNING: shift/reduce conflict for OR in state 153 resolved as shift
WARNING: shift/reduce conflict for ? in state 153 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MULT in state 154 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 154 resolved as shift
WARNING: shift/reduce conflict for MOD in state 154 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 154 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 154 resolved as shift
WARNING: shift/reduce conflict for LTE in state 154 resolved as shift
WARNING: shift/reduce conflict for GTE in state 154 resolved as shift
WARNING: shift/reduce conflict for GT in state 154 resolved as shift
WARNING: shift/reduce conflict for LT in state 154 resolved as shift
WARNING: shift/reduce conflict for AND in state 154 resolved as shift
WARNING: shift/reduce conflict for OR in state 154 resolved as shift
WARNING: shift/reduce conflict for ? in state 154 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MULT in state 155 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 155 resolved as shift
WARNING: shift/reduce conflict for MOD in state 155 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 155 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 155 resolved as shift
WARNING: shift/reduce conflict for LTE in state 155 resolved as shift
WARNING: shift/reduce conflict for GTE in state 155 resolved as shift
WARNING: shift/reduce conflict for GT in state 155 resolved as shift
WARNING: shift/reduce conflict for LT in state 155 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for OR in state 155 resolved as shift
WARNING: shift/reduce conflict for ? in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MULT in state 156 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 156 resolved as shift
WARNING: shift/reduce conflict for MOD in state 156 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 156 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 156 resolved as shift
WARNING: shift/reduce conflict for LTE in state 156 resolved as shift
WARNING: shift/reduce conflict for GTE in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for ? in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MULT in state 157 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 157 resolved as shift
WARNING: shift/reduce conflict for MOD in state 157 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 157 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 157 resolved as shift
WARNING: shift/reduce conflict for LTE in state 157 resolved as shift
WARNING: shift/reduce conflict for GTE in state 157 resolved as shift
WARNING: shift/reduce conflict for GT in state 157 resolved as shift
WARNING: shift/reduce conflict for LT in state 157 resolved as shift
WARNING: shift/reduce conflict for AND in state 157 resolved as shift
WARNING: shift/reduce conflict for OR in state 157 resolved as shift
WARNING: shift/reduce conflict for ? in state 157 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MULT in state 171 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for MOD in state 171 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 171 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 171 resolved as shift
WARNING: shift/reduce conflict for LTE in state 171 resolved as shift
WARNING: shift/reduce conflict for GTE in state 171 resolved as shift
WARNING: shift/reduce conflict for GT in state 171 resolved as shift
WARNING: shift/reduce conflict for LT in state 171 resolved as shift
WARNING: shift/reduce conflict for AND in state 171 resolved as shift
WARNING: shift/reduce conflict for OR in state 171 resolved as shift
WARNING: shift/reduce conflict for ? in state 171 resolved as shift
